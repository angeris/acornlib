{"goal":"map[Nat, A](List.singleton(0), f) = List.singleton(f(0))","proof":["List.cons(0, List.nil[Nat]) = List.singleton(0)","List.cons(f(0), List.nil[A]) = List.singleton(f(0))","map[Nat, A](List.nil[Nat], f) = List.nil[A]","List.cons(f(0), map[Nat, A](List.nil[Nat], f)) = map[Nat, A](List.cons(0, List.nil[Nat]), f)"]}
{"goal":"partial_one","proof":["sum[A](map[Nat, A](1.range, f)) = partial[A](f, 1)","List.nil[Nat] + List.singleton(0) = List.nil[Nat].append(0)","List.cons(f(0), List.nil[A]) = List.singleton(f(0))","f(0) + A.0 = f(0)","List.nil[Nat] + List.singleton(0) = List.singleton(0)","0.range.append(0) = 0.suc.range","f(0) + sum[A](List.nil[A]) = sum[A](List.cons(f(0), List.nil[A]))"]}
{"goal":"p(List.nil[T])","proof":["sum[A](map[T, A](List.nil[T], f)) + sum[A](map[T, A](List.nil[T], g)) != sum[A](map[T, A](List.nil[T], add_fn[T, A](f, g))) or p(List.nil[T])","sum[A](List.nil[A]) + A.0 = sum[A](List.nil[A])","map[T, A](List.nil[T], add_fn[T, A](f, g)) = List.nil[A]","map[T, A](List.nil[T], f) = List.nil[A]","map[T, A](List.nil[T], g) = List.nil[A]"]}
{"goal":"f(head) + (g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)))) = f(head) + g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)))","proof":["f(head) + g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g))) = f(head) + (g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g))))"]}
{"goal":"f(head) + g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g))) = f(head) + g(head) + sum[A](map[T, A](tail, add_fn[T, A](f, g)))","proof":["not p(tail) or sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)) = sum[A](map[T, A](tail, add_fn[T, A](f, g)))"]}
{"goal":"p(List.cons(head, tail))","proof":["sum[A](map[T, A](List.cons(head, tail), f)) + sum[A](map[T, A](List.cons(head, tail), g)) != sum[A](map[T, A](List.cons(head, tail), add_fn[T, A](f, g))) or p(List.cons(head, tail))","f(head) + sum[A](map[T, A](tail, f)) + (g(head) + sum[A](map[T, A](tail, g))) = f(head) + (sum[A](map[T, A](tail, f)) + (g(head) + sum[A](map[T, A](tail, g))))","g(head) + sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)) = g(head) + (sum[A](map[T, A](tail, f)) + sum[A](map[T, A](tail, g)))","sum[A](map[T, A](tail, f)) + (g(head) + sum[A](map[T, A](tail, g))) = sum[A](map[T, A](tail, f)) + g(head) + sum[A](map[T, A](tail, g))","f(head) + g(head) = add_fn[T, A](f, g, head)","sum[A](map[T, A](tail, f)) + g(head) = g(head) + sum[A](map[T, A](tail, f))","A.0 + f(head) = f(head)","sum[A](List.cons(A.0 + f(head), map[T, A](tail, f))) = A.0 + f(head) + sum[A](map[T, A](tail, f))","sum[A](List.cons(f(head) + g(head), map[T, A](tail, add_fn[T, A](f, g)))) = f(head) + g(head) + sum[A](map[T, A](tail, add_fn[T, A](f, g)))","sum[A](List.cons(g(head), map[T, A](tail, g))) = g(head) + sum[A](map[T, A](tail, g))","List.cons(add_fn[T, A](f, g, head), map[T, A](tail, add_fn[T, A](f, g))) = map[T, A](List.cons(head, tail), add_fn[T, A](f, g))","List.cons(f(head), map[T, A](tail, f)) = map[T, A](List.cons(head, tail), f)","List.cons(g(head), map[T, A](tail, g)) = map[T, A](List.cons(head, tail), g)"]}
{"goal":"map_sum_add","proof":["let (s0: (List[T] -> Bool) -> T, s1: (List[T] -> Bool) -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not p(list) or sum[A](map[T, A](list, f)) + sum[A](map[T, A](list, g)) = sum[A](map[T, A](list, add_fn[T, A](f, g)))","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(list)","not p(List.nil[T]) or p(s1(p)) or p(list)"]}
{"goal":"partial_add","proof":["sum[A](map[Nat, A](n.range, f)) + sum[A](map[Nat, A](n.range, g)) = sum[A](map[Nat, A](n.range, add_fn[Nat, A](f, g)))","sum[A](map[Nat, A](n.range, add_fn[Nat, A](f, g))) = partial[A](add_fn[Nat, A](f, g), n)","sum[A](map[Nat, A](n.range, f)) = partial[A](f, n)","sum[A](map[Nat, A](n.range, g)) = partial[A](g, n)"]}
{"goal":"p(List.nil[S])","proof":["sum[S](map[S, S](List.nil[S], scalar_mul(c))) != c * sum[S](List.nil[S]) or p(List.nil[S])","c * S.0 = S.0","map[S, S](List.nil[S], scalar_mul(c)) = List.nil[S]"]}
{"goal":"c * sum[S](List.cons(head, tail)) = sum[S](map[S, S](List.cons(head, tail), scalar_mul(c)))","proof":["not p(tail) or sum[S](map[S, S](tail, scalar_mul(c))) = c * sum[S](tail)","c * head + c * sum[S](tail) = c * (head + sum[S](tail))","let s0: S satisfy { true }","sum[S](List.cons(head, tail)) = head + sum[S](tail)","sum[S](List.cons(scalar_mul(c, head), map[S, S](tail, scalar_mul(c)))) = scalar_mul(c, head) + sum[S](map[S, S](tail, scalar_mul(c)))","List.cons(scalar_mul(c, head), map[S, S](tail, scalar_mul(c))) = map[S, S](List.cons(head, tail), scalar_mul(c))"]}
{"goal":"sum_scalar_mul","proof":["let (s0: (List[S] -> Bool) -> S, s1: (List[S] -> Bool) -> List[S]) satisfy { forall(x0: List[S] -> Bool, x1: List[S]) { not x0(List.nil[S]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[S] -> Bool, x3: List[S]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[S]) or x2(x3) } }","sum[S](map[S, S](List.cons(s0(p), s1(p)), scalar_mul(c))) != c * sum[S](List.cons(s0(p), s1(p))) or p(List.cons(s0(p), s1(p)))","not p(list) or sum[S](map[S, S](list, scalar_mul(c))) = c * sum[S](list)","not p(s1(p)) or sum[S](map[S, S](List.cons(s0(p), s1(p)), scalar_mul(c))) = c * sum[S](List.cons(s0(p), s1(p)))","not p(List.cons(s0(p), s1(p))) or not p(List.nil[S]) or p(list)","not p(List.nil[S]) or p(s1(p)) or p(list)"]}
{"goal":"p(List.nil[A])","proof":["sum[A](List.nil[A]) + sum[A](right) != sum[A](List.nil[A] + right) or p(List.nil[A])","A.0 + sum[A](right) = sum[A](right)","List.nil[A] + right = right"]}
{"goal":"p(List.cons(head, tail))","proof":["sum[A](List.cons(head, tail)) + sum[A](right) != sum[A](List.cons(head, tail) + right) or p(List.cons(head, tail))","not p(tail) or sum[A](tail) + sum[A](right) = sum[A](tail + right)","head + sum[A](tail) + sum[A](right) = head + (sum[A](tail) + sum[A](right))","head + sum[A](tail + right) = sum[A](List.cons(head, tail + right))","head + sum[A](tail) = sum[A](List.cons(head, tail))","List.cons(head, tail) + right = List.cons(head, tail + right)"]}
{"goal":"sum_add","proof":["let (s0: (List[A] -> Bool) -> A, s1: (List[A] -> Bool) -> List[A]) satisfy { forall(x0: List[A] -> Bool, x1: List[A]) { not x0(List.nil[A]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[A] -> Bool, x3: List[A]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[A]) or x2(x3) } }","not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not p(left) or sum[A](left) + sum[A](right) = sum[A](left + right)","not p(List.cons(s0(p), s1(p))) or not p(List.nil[A]) or p(left)","not p(List.nil[A]) or p(s1(p)) or p(left)"]}
{"goal":"p(List.nil[T])","proof":["map[T, U](List.nil[T], f) + map[T, U](right, f) != map[T, U](List.nil[T] + right, f) or p(List.nil[T])","List.nil[U] + map[T, U](right, f) = map[T, U](right, f)","List.nil[T] + right = right","map[T, U](List.nil[T], f) = List.nil[U]"]}
{"goal":"p(List.cons(head, tail))","proof":["map[T, U](List.cons(head, tail), f) + map[T, U](right, f) != map[T, U](List.cons(head, tail) + right, f) or p(List.cons(head, tail))","not p(tail) or map[T, U](tail, f) + map[T, U](right, f) = map[T, U](tail + right, f)","List.cons(head, tail) + right = List.cons(head, tail + right)","List.cons(f(head), map[T, U](tail, f)) + map[T, U](right, f) = List.cons(f(head), map[T, U](tail, f) + map[T, U](right, f))","List.cons(f(head), map[T, U](tail + right, f)) = map[T, U](List.cons(head, tail + right), f)","List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)"]}
{"goal":"map_add","proof":["let (s0: (List[T] -> Bool) -> T, s1: (List[T] -> Bool) -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not p(left) or map[T, U](left, f) + map[T, U](right, f) = map[T, U](left + right, f)","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(left)","not p(List.nil[T]) or p(s1(p)) or p(left)"]}
{"goal":"map_append","proof":["map[T, U](initial, f) + map[T, U](List.singleton(last), f) = map[T, U](initial + List.singleton(last), f)","map[T, U](initial, f) + List.singleton(f(last)) = map[T, U](initial, f).append(f(last))","initial + List.singleton(last) = initial.append(last)","List.cons(f(last), List.nil[U]) = List.singleton(f(last))","List.cons(last, List.nil[T]) = List.singleton(last)","map[T, U](List.nil[T], f) = List.nil[U]","List.cons(f(last), map[T, U](List.nil[T], f)) = map[T, U](List.cons(last, List.nil[T]), f)"]}
{"goal":"sum_append","proof":["sum[A](initial) + sum[A](List.singleton(last)) = sum[A](initial + List.singleton(last))","initial + List.singleton(last) = initial.append(last)","List.cons(last, List.nil[A]) = List.singleton(last)","last + A.0 = last","last + sum[A](List.nil[A]) = sum[A](List.cons(last, List.nil[A]))"]}
{"goal":"p(List.nil[T])","proof":["List.nil[T] + b + c != List.nil[T] + (b + c) or p(List.nil[T])","List.nil[T] + (b + c) = b + c","List.nil[T] + b = b"]}
{"goal":"p(List.cons(head, tail))","proof":["List.cons(head, tail) + b + c != List.cons(head, tail) + (b + c) or p(List.cons(head, tail))","not p(tail) or tail + b + c = tail + (b + c)","List.cons(head, tail + b) + c = List.cons(head, tail + b + c)","List.cons(head, tail) + (b + c) = List.cons(head, tail + (b + c))","List.cons(head, tail) + b = List.cons(head, tail + b)"]}
{"goal":"add_assoc","proof":["let (s0: (List[T] -> Bool) -> T, s1: (List[T] -> Bool) -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not p(a) or a + b + c = a + (b + c)","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(a)","not p(List.nil[T]) or p(s1(p)) or p(a)"]}
{"goal":"map_singleton","proof":["List.cons(f(x), List.nil[U]) = List.singleton(f(x))","List.cons(x, List.nil[T]) = List.singleton(x)","map[T, U](List.nil[T], f) = List.nil[U]","List.cons(f(x), map[T, U](List.nil[T], f)) = map[T, U](List.cons(x, List.nil[T]), f)"]}
{"goal":"length_zero_imp_nil","proof":["let (s0: List[T] -> T, s1: List[T] -> List[T]) satisfy { forall(x0: List[T]) { List.cons(s0(x0), s1(x0)) = x0 or List.nil[T] = x0 } }","List.cons(s0(list), s1(list)) != list or s1(list).length.suc = list.length","List.cons(s0(list), s1(list)) = list or List.nil[T] = list","s1(list).length.suc != 0"]}
{"goal":"add_to_nil","proof":["a.length + b.length = (a + b).length","a.length + b.length != 0 or b.length = 0","a.length + b.length != 0 or a.length = 0","a.length != 0 or List.nil[T] = a","b.length != 0 or List.nil[T] = b"]}
{"goal":"append_not_nil","proof":["a + List.singleton(t) = a.append(t)","a + List.singleton(t) != List.nil[T] or List.singleton(t) = List.nil[T]","List.cons(t, List.nil[T]) = List.singleton(t)","List.cons(t, List.nil[T]) != List.nil[T]"]}
{"goal":"p(List.nil[T])","proof":["map[T, V](List.nil[T], compose[T, U, V](g, f)) != map[U, V](map[T, U](List.nil[T], f), g) or p(List.nil[T])","map[T, U](List.nil[T], f) != List.nil[U] or map[U, V](map[T, U](List.nil[T], f), g) = List.nil[V]","map[T, U](List.nil[T], f) = List.nil[U]","map[T, V](List.nil[T], compose[T, U, V](g, f)) = List.nil[V]"]}
{"goal":"p(List.cons(head, tail))","proof":["map[T, V](List.cons(head, tail), compose[T, U, V](g, f)) != map[U, V](map[T, U](List.cons(head, tail), f), g) or p(List.cons(head, tail))","not p(tail) or map[T, V](tail, compose[T, U, V](g, f)) = map[U, V](map[T, U](tail, f), g)","compose[T, U, V](g, f, head) = g(f(head))","List.cons(g(f(head)), map[U, V](map[T, U](tail, f), g)) = map[U, V](List.cons(f(head), map[T, U](tail, f)), g)","List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","List.cons(compose[T, U, V](g, f, head), map[T, V](tail, compose[T, U, V](g, f))) = map[T, V](List.cons(head, tail), compose[T, U, V](g, f))"]}
{"goal":"map_map","proof":["let (s0: (List[T] -> Bool) -> T, s1: (List[T] -> Bool) -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not p(items) or map[T, V](items, compose[T, U, V](g, f)) = map[U, V](map[T, U](items, f), g)","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(items)","not p(List.nil[T]) or p(s1(p)) or p(items)"]}
{"goal":"compose[Nat, S, S](scalar_mul(c), f) = mul_fn[Nat, S](c, f)","proof":["let s0: Nat satisfy { compose[Nat, S, S](scalar_mul(c), f, s0) != mul_fn(c, f, s0) }","mul_fn(c, f, s0) = c * f(s0)","compose[Nat, S, S](scalar_mul(c), f, s0) = scalar_mul(c, f(s0))"]}
{"goal":"partial_scalar_mul","proof":["map[S, S](map[Nat, S](n.range, f), scalar_mul(c)) = map[Nat, S](n.range, compose[Nat, S, S](scalar_mul(c), f))","sum[S](map[S, S](map[Nat, S](n.range, f), scalar_mul(c))) = c * sum[S](map[Nat, S](n.range, f))","sum[S](map[Nat, S](n.range, f)) = partial[S](f, n)","sum[S](map[Nat, S](n.range, mul_fn[Nat, S](c, f))) = partial[S](mul_fn[Nat, S](c, f), n)"]}
{"goal":"f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), 0) = partial[A](f, 0.suc)","proof":["sum[A](map[Nat, A](0.range, compose[Nat, Nat, A](f, Nat.suc))) = partial[A](compose[Nat, Nat, A](f, Nat.suc), 0)","partial[A](f, 1) = f(0)","partial[A](f, 0.suc) + A.0 = partial[A](f, 0.suc)","map[Nat, A](List.nil[Nat], compose[Nat, Nat, A](f, Nat.suc)) = List.nil[A]"]}
{"goal":"sum[A](map[Nat, A](k.suc.range, compose[Nat, Nat, A](f, Nat.suc))) = partial[A](compose[Nat, Nat, A](f, Nat.suc), k) + f(k.suc)","proof":["map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc)).append(compose[Nat, Nat, A](f, Nat.suc, k)) = map[Nat, A](k.range.append(k), compose[Nat, Nat, A](f, Nat.suc))","sum[A](map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc))) = partial[A](compose[Nat, Nat, A](f, Nat.suc), k)","sum[A](map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc)).append(f(k.suc))) = sum[A](map[Nat, A](k.range, compose[Nat, Nat, A](f, Nat.suc))) + f(k.suc)","compose[Nat, Nat, A](f, Nat.suc, k) = f(k.suc)","k.range.append(k) = k.suc.range"]}
{"goal":"f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k) + f(k.suc) = partial[A](f, k.suc) + f(k.suc)","proof":["not p(k) or f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k) = partial[A](f, k.suc)"]}
{"goal":"sum[A](map[Nat, A](k.suc.suc.range, f)) = partial[A](f, k.suc) + f(k.suc)","proof":["map[Nat, A](k.suc.range, f).append(f(k.suc)) = map[Nat, A](k.suc.range.append(k.suc), f)","sum[A](map[Nat, A](k.suc.range, f)) = partial[A](f, k.suc)","sum[A](map[Nat, A](k.suc.range, f).append(f(k.suc))) = sum[A](map[Nat, A](k.suc.range, f)) + f(k.suc)","k.suc.range.append(k.suc) = k.suc.suc.range"]}
{"goal":"p(k.suc)","proof":["f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k.suc) != partial[A](f, k.suc.suc) or p(k.suc)","f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), k) + f(k.suc) = f(0) + (partial[A](compose[Nat, Nat, A](f, Nat.suc), k) + f(k.suc))","sum[A](map[Nat, A](k.suc.range, compose[Nat, Nat, A](f, Nat.suc))) = partial[A](compose[Nat, Nat, A](f, Nat.suc), k.suc)","sum[A](map[Nat, A](k.suc.suc.range, f)) = partial[A](f, k.suc.suc)"]}
{"goal":"partial_shift_suc","proof":["let s0: (Nat -> Bool) -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(s0(x2).suc) or not x2(0) or x2(x3) } }","not p(s0(p)) or p(s0(p).suc)","f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), 0) != partial[A](f, 0.suc) or p(0)","not p(n) or f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n) = partial[A](f, n.suc)","not p(s0(p).suc) or not p(0) or p(n)","not p(0) or p(s0(p)) or p(n)"]}
{"goal":"partial_split_last","proof":["map[Nat, A](n.range, f).append(f(n)) = map[Nat, A](n.range.append(n), f)","sum[A](map[Nat, A](n.range, f)) = partial[A](f, n)","sum[A](map[Nat, A](n.suc.range, f)) = partial[A](f, n.suc)","sum[A](map[Nat, A](n.range, f).append(f(n))) = sum[A](map[Nat, A](n.range, f)) + f(n)","n.range.append(n) = n.suc.range"]}
{"goal":"p(0)","proof":["partial[A](g, 0) != partial[A](f, 0) or p(0)","sum[A](map[Nat, A](0.range, f)) = partial[A](f, 0)","sum[A](map[Nat, A](0.range, g)) = partial[A](g, 0)","map[Nat, A](List.nil[Nat], f) = List.nil[A]","map[Nat, A](List.nil[Nat], g) = List.nil[A]"]}
{"goal":"partial[A](f, m.suc) = partial[A](g, m) + f(m)","proof":["let s0: Nat -> Nat satisfy { forall(x0: Nat) { not p(x0) or s0(x0) < x0 or partial[A](g, x0) = partial[A](f, x0) } and forall(x1: Nat) { g(s0(x1)) != f(s0(x1)) or not p(x1) or partial[A](g, x1) = partial[A](f, x1) } and forall(x2: Nat, x3: Nat) { not x2 < x3 or p(x3) or g(x2) = f(x2) } and forall(x4: Nat) { partial[A](g, x4) != partial[A](f, x4) or p(x4) } }","not s0(m) < m.suc or g(s0(m)) = f(s0(m))","not p(m) or s0(m) < m or partial[A](g, m) = partial[A](f, m)","g(s0(m)) != f(s0(m)) or not p(m) or partial[A](g, m) = partial[A](f, m)","partial[A](f, m) + f(m) = partial[A](f, m.suc)","not s0(m) < m or s0(m) < m.suc","partial[A](g, m) + f(m) != partial[A](f, m) + f(m)"]}
{"goal":"partial[A](f, m.suc) = partial[A](g, m.suc)","proof":["not m < m.suc or g(m) = f(m)","partial[A](g, m) + g(m) = partial[A](g, m.suc)","m < m.suc"]}
{"goal":"p(n)","proof":["let s0: (Nat -> Bool) -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(s0(x2).suc) or not x2(0) or x2(x3) } }","partial[A](g, s0(p).suc) != partial[A](f, s0(p).suc) or p(s0(p).suc)","let s1: Nat -> Nat satisfy { forall(x4: Nat) { not p(x4) or s1(x4) < x4.suc or partial[A](g, x4.suc) = partial[A](f, x4.suc) } and forall(x5: Nat) { g(s1(x5)) != f(s1(x5)) or not p(x5) or partial[A](g, x5.suc) = partial[A](f, x5.suc) } }","not s1(s0(p)) < s0(p).suc or p(s0(p).suc) or g(s1(s0(p))) = f(s1(s0(p)))","not p(s0(p)) or s1(s0(p)) < s0(p).suc or partial[A](g, s0(p).suc) = partial[A](f, s0(p).suc)","g(s1(s0(p))) != f(s1(s0(p))) or not p(s0(p)) or partial[A](g, s0(p).suc) = partial[A](f, s0(p).suc)","not p(s0(p).suc) or not p(0) or p(n)","not p(0) or p(s0(p)) or p(n)"]}
{"goal":"partial_pointwise_eq","proof":["let s0: Nat -> Nat satisfy { forall(x0: Nat) { not p(x0) or s0(x0) < x0 or partial[A](g, x0) = partial[A](f, x0) } and forall(x1: Nat) { g(s0(x1)) != f(s0(x1)) or not p(x1) or partial[A](g, x1) = partial[A](f, x1) } and forall(x2: Nat, x3: Nat) { not x2 < x3 or p(x3) or g(x2) = f(x2) } and forall(x4: Nat) { partial[A](g, x4) != partial[A](f, x4) or p(x4) } }","not s0(n) < n or g(s0(n)) = f(s0(n))","not p(n) or s0(n) < n or partial[A](g, n) = partial[A](f, n)","g(s0(n)) != f(s0(n)) or not p(n) or partial[A](g, n) = partial[A](f, n)"]}
{"goal":"partial[A](g, 1) = g(0)","proof":["partial[A](g, 1) = g(0)"]}
{"goal":"reverse_index[A](g, 0, 0) = g(0 - 0)","proof":["reverse_index[A](g, 0, 0) = g(0 - 0)"]}
{"goal":"0 - 0 = 0","proof":["0 + 0 != 0 or 0 - 0 = 0","0 + 0 != 0","0 != 0 or 0 + 0 = 0"]}
{"goal":"reverse_index[A](g, 0, 0) = g(0)","proof":["reverse_index[A](g, 0, 0) != g(0 - 0)"]}
{"goal":"partial[A](reverse_index[A](g, 0), 1) = reverse_index[A](g, 0, 0)","proof":["partial[A](reverse_index[A](g, 0), 1) = reverse_index[A](g, 0, 0)"]}
{"goal":"partial[A](g, 1) = partial[A](reverse_index[A](g, 0), 1)","proof":[]}
{"goal":"p(0)","proof":["partial[A](reverse_index[A](g, 0), 0.suc) != partial[A](g, 0.suc) or p(0)","0 + 1 = 0.suc","0 + 1 = 1","partial[A](reverse_index[A](g, 0), 0.suc) != partial[A](g, 0.suc)"]}
{"goal":"partial[A](g, m.suc.suc) = partial[A](g, m.suc) + g(m.suc)","proof":["partial[A](g, m.suc) + g(m.suc) = partial[A](g, m.suc.suc)"]}
{"goal":"partial[A](reverse_index[A](g, m.suc), m.suc.suc) = partial[A](reverse_index[A](g, m.suc), m.suc) + reverse_index[A](g, m.suc, m.suc)","proof":["partial[A](reverse_index[A](g, m.suc), m.suc) + reverse_index[A](g, m.suc, m.suc) = partial[A](reverse_index[A](g, m.suc), m.suc.suc)"]}
{"goal":"reverse_index[A](g, m.suc, m.suc) = g(m.suc - m.suc)","proof":["reverse_index[A](g, m.suc, m.suc) = g(m.suc - m.suc)"]}
{"goal":"m.suc - m.suc = 0","proof":["0 + m.suc != m.suc or m.suc - m.suc = 0","0 + m.suc != m.suc","0 + m.suc = m.suc"]}
{"goal":"reverse_index[A](g, m.suc, m.suc) = g(0)","proof":["reverse_index[A](g, m.suc, m.suc) != g(m.suc - m.suc)"]}
{"goal":"m.suc > 0","proof":["m.suc > 0 = 0 < m.suc","not 0 < m.suc","0 < 0 + m.suc","0 + m.suc = m.suc"]}
{"goal":"partial[A](reverse_index[A](g, m.suc), m.suc) = reverse_index[A](g, m.suc, 0) + partial[A](compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc), m.suc - 1)","proof":["reverse_index[A](g, m.suc, 0) + partial[A](compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc), m) = partial[A](reverse_index[A](g, m.suc), m.suc)","m.suc - 1 = m"]}
{"goal":"reverse_index[A](g, m.suc, 0) = g(m.suc - 0)","proof":["reverse_index[A](g, m.suc, 0) = g(m.suc - 0)"]}
{"goal":"m.suc - 0 = m.suc","proof":["m.suc + 0 != m.suc or m.suc - 0 = m.suc","0 != 0 or m.suc + 0 = m.suc","m.suc + 0 != m.suc"]}
{"goal":"reverse_index[A](g, m.suc, 0) = g(m.suc)","proof":["reverse_index[A](g, m.suc, 0) != g(m.suc - 0)"]}
{"goal":"m.suc - 1 = m","proof":["m.suc - 1 = m"]}
{"goal":"partial[A](reverse_index[A](g, m.suc), m.suc) = g(m.suc) + partial[A](compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc), m)","proof":[]}
{"goal":"compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc, i) = reverse_index[A](g, m.suc, i.suc)","proof":["compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc, i) = reverse_index[A](g, m.suc, i.suc)"]}
{"goal":"reverse_index[A](g, m.suc, i.suc) = g(m.suc - i.suc)","proof":["reverse_index[A](g, m.suc, i.suc) = g(m.suc - i.suc)"]}
{"goal":"m.suc - i.suc = m - i","proof":["not i <= m or m - i + i = m","m - i + i.suc != m.suc or m.suc - i.suc = m - i","m - i + i.suc = (m - i + i).suc","not i < m or i <= m","i <= m","m - i + i.suc != m.suc","(m - i + i).suc != m.suc","m - i + i = m","m - i + i != m"]}
{"goal":"reverse_index[A](g, m, i) = g(m - i)","proof":["reverse_index[A](g, m, i) = g(m - i)"]}
{"goal":"compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc, i) = reverse_index[A](g, m, i)","proof":[]}
{"goal":"partial[A](compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc), m) = partial[A](reverse_index[A](g, m), m)","proof":["let s0: Nat satisfy { partial[A](compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc), m) = partial[A](reverse_index[A](g, m), m) or s0 < m and (compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc, s0) != reverse_index[A](g, m, s0) or partial[A](compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc), m) = partial[A](reverse_index[A](g, m), m)) }","not s0 < m or compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc, s0) = reverse_index[A](g, m, s0)"]}
{"goal":"partial[A](reverse_index[A](g, m.suc), m.suc) = g(m.suc) + partial[A](reverse_index[A](g, m), m)","proof":["g(m.suc) + partial[A](compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc), m) != partial[A](reverse_index[A](g, m.suc), m.suc)"]}
{"goal":"partial[A](reverse_index[A](g, m), m.suc) = partial[A](reverse_index[A](g, m), m) + reverse_index[A](g, m, m)","proof":["partial[A](reverse_index[A](g, m), m) + reverse_index[A](g, m, m) = partial[A](reverse_index[A](g, m), m.suc)"]}
{"goal":"reverse_index[A](g, m, m) = g(m - m)","proof":["reverse_index[A](g, m, m) = g(m - m)"]}
{"goal":"m - m = 0","proof":["0 + m != m or m - m = 0","0 + m != m","0 + m = m"]}
{"goal":"reverse_index[A](g, m, m) = g(0)","proof":["reverse_index[A](g, m, m) != g(m - m)"]}
{"goal":"partial[A](reverse_index[A](g, m), m.suc) = partial[A](reverse_index[A](g, m), m) + g(0)","proof":["partial[A](reverse_index[A](g, m), m) + reverse_index[A](g, m, m) != partial[A](reverse_index[A](g, m), m.suc)"]}
{"goal":"partial[A](reverse_index[A](g, m), m.suc) + g(m.suc) = partial[A](reverse_index[A](g, m.suc), m.suc) + g(0)","proof":["g(m.suc) + partial[A](reverse_index[A](g, m), m) + g(0) = g(m.suc) + (partial[A](reverse_index[A](g, m), m) + g(0))","partial[A](reverse_index[A](g, m), m.suc) + g(m.suc) = g(m.suc) + partial[A](reverse_index[A](g, m), m.suc)"]}
{"goal":"p(m.suc)","proof":["partial[A](reverse_index[A](g, m.suc), m.suc.suc) != partial[A](g, m.suc.suc) or p(m.suc)","not p(m) or partial[A](reverse_index[A](g, m), m.suc) = partial[A](g, m.suc)","reverse_index[A](g, m.suc, 0) + partial[A](compose[Nat, Nat, A](reverse_index[A](g, m.suc), Nat.suc), m.suc) = partial[A](reverse_index[A](g, m.suc), m.suc.suc)","partial[A](g, m.suc) + g(m.suc) = g(m.suc) + partial[A](g, m.suc)","partial[A](reverse_index[A](g, m.suc), m.suc.suc) != partial[A](g, m.suc.suc)","partial[A](reverse_index[A](g, m), m.suc) = partial[A](g, m.suc)"]}
{"goal":"partial_reverse","proof":["let s0: (Nat -> Bool) -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(s0(x2).suc) or not x2(0) or x2(x3) } }","not p(s0(p)) or p(s0(p).suc)","not p(n) or partial[A](reverse_index[A](g, n), n.suc) = partial[A](g, n.suc)","not p(n)","not p(s0(p).suc) or not p(0) or p(n)","not p(0) or p(s0(p)) or p(n)","p(s0(p)) or p(n)","p(s0(p))","not p(s0(p).suc)","p(s0(p).suc)"]}
{"goal":"partial_drop_first","proof":["f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 1) = partial[A](f, (n - 1).suc)","partial[A](f, (n - 1).suc) != partial[A](f, n)","not 1 <= n or n - 1 + 1 = n","not 0 < n or 0.suc <= n","n > 0 = 0 < n","n - 1 + 1 = (n - 1).suc"]}
{"goal":"exists(k0: Nat) { k0.suc = n }","proof":["let s0: Nat -> Nat satisfy { forall(x0: Nat) { s0(x0).suc = x0 or 0 = x0 } }","s0(n).suc != n","2 <= n = n >= 2","s0(n).suc = n or 0 = n","not 2 <= 0 or 2 = 0"]}
{"goal":"exists(k0: Nat) { k0.suc = n_minus_1 }","proof":["let s0: Nat -> Nat satisfy { forall(x0: Nat) { s0(x0).suc = x0 or 0 = x0 } }","s0(n_minus_1).suc != n_minus_1","not 0.suc ∈ 2.range or not 0.suc >= 2","s0(n_minus_1).suc = n_minus_1 or n_minus_1 = 0","1 ∈ 1.suc.range"]}
{"goal":"n - 2 = n_minus_2","proof":["n_minus_2 + 2 != n or n - 2 = n_minus_2","n_minus_2 + 1.suc = (n_minus_2 + 1).suc","n_minus_2 + 1 = n_minus_2.suc"]}
{"goal":"partial[A](f, n) = f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 2) + f(n - 1)","proof":["let s0: Nat satisfy { s0.suc = n }","f(0) + partial[A](compose[Nat, Nat, A](f, Nat.suc), n - 2) = partial[A](f, (n - 2).suc)","partial[A](f, s0) + f(s0) = partial[A](f, s0.suc)","(n - 2).suc.suc - 1 = (n - 2).suc","s0.suc - 1 = s0"]}
{"goal":"partial_split_first_last","proof":[]}
{"goal":"p(List.nil[T])","proof":["map[T, U](List.nil[T], f).length != List.nil[T].length or p(List.nil[T])","map[T, U](List.nil[T], f) = List.nil[U]"]}
{"goal":"map[T, U](List.cons(head, tail), f).length = List.cons(head, tail).length","proof":["not p(tail) or map[T, U](tail, f).length = tail.length","List.cons(f(head), map[T, U](tail, f)).length = map[T, U](tail, f).length.suc","List.cons(head, tail).length = tail.length.suc","List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)"]}
{"goal":"p(list)","proof":["let (s0: (List[T] -> Bool) -> T, s1: (List[T] -> Bool) -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","map[T, U](List.cons(s0(p), s1(p)), f).length != List.cons(s0(p), s1(p)).length or p(List.cons(s0(p), s1(p)))","not p(s1(p)) or map[T, U](List.cons(s0(p), s1(p)), f).length = List.cons(s0(p), s1(p)).length","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(list)","not p(List.nil[T]) or p(s1(p)) or p(list)"]}
{"goal":"map_length","proof":["not p(list) or map[T, U](list, f).length = list.length"]}
{"goal":"p(List.nil[T])","proof":["item ∈ map[T, U](List.nil[T], f) or p(List.nil[T])","not item ∈ List.nil[U]","map[T, U](List.nil[T], f) = List.nil[U]"]}
{"goal":"p(List.cons(head, tail))","proof":["not head ∈ List.cons(head, tail) or f(head) != item or p(List.cons(head, tail))","not item ∈ List.cons(f(head), map[T, U](tail, f)) or item ∈ map[T, U](tail, f) or f(head) = item","List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","head ∈ List.cons(head, tail)"]}
{"goal":"p(List.cons(head, tail))","proof":["item ∈ map[T, U](List.cons(head, tail), f) or p(List.cons(head, tail))","let s0: List[T] -> T satisfy { forall(x0: List[T]) { not item ∈ map[T, U](x0, f) or not p(x0) or s0(x0) ∈ x0 } and forall(x1: List[T]) { not item ∈ map[T, U](x1, f) or not p(x1) or f(s0(x1)) = item } and forall(x2: List[T]) { item ∈ map[T, U](x2, f) or p(x2) } and forall(x3: List[T], x4: T) { not x4 ∈ x3 or item != f(x4) or p(x3) } }","not s0(tail) ∈ List.cons(head, List.nil[T]) + tail or f(s0(tail)) != item or p(List.cons(head, List.nil[T]) + tail)","not item ∈ map[T, U](tail, f) or not p(tail) or f(s0(tail)) = item","not item ∈ map[T, U](tail, f) or not p(tail) or s0(tail) ∈ tail","not s0(tail) ∈ tail or s0(tail) ∈ List.cons(head, List.nil[T]) + tail","List.nil[T] + tail = tail","List.cons(head, List.nil[T]) + tail = List.cons(head, List.nil[T] + tail)"]}
{"goal":"map_contains","proof":["let s0: List[T] -> T satisfy { forall(x0: List[T]) { not item ∈ map[T, U](x0, f) or not p(x0) or s0(x0) ∈ x0 } and forall(x1: List[T]) { not item ∈ map[T, U](x1, f) or not p(x1) or f(s0(x1)) = item } and forall(x2: List[T]) { item ∈ map[T, U](x2, f) or p(x2) } and forall(x3: List[T], x4: T) { not x4 ∈ x3 or item != f(x4) or p(x3) } }","not s0(list) ∈ list or f(s0(list)) != item","let (s1: T, s2: List[T]) satisfy { forall(x5: List[T]) { not p(List.nil[T]) or p(s2) or p(x5) } and forall(x6: List[T]) { not p(List.cons(s1, s2)) or not p(List.nil[T]) or p(x6) } }","not p(List.nil[T]) or p(s2) or p(s2)","not p(List.cons(s1, s2)) or not p(List.nil[T]) or p(list)","not p(s2) or p(List.cons(s1, s2))","not item ∈ map[T, U](list, f) or not p(list) or f(s0(list)) = item","not item ∈ map[T, U](list, f) or not p(list) or s0(list) ∈ list"]}
{"goal":"p(List.nil[T])","proof":["item ∈ List.nil[T] or p(List.nil[T])","item ∈ List.nil[T]","not item ∈ List.nil[T] or List.nil[T] != List.nil[T]"]}
{"goal":"map[T, U](List.cons(head, tail), f).contains(f(item))","proof":["List.cons(head, tail) != List.cons(head, tail) or List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","List.cons(f(head), map[T, U](tail, f)) != map[T, U](List.cons(head, tail), f) or f(head) != f(item) or f(item) ∈ map[T, U](List.cons(head, tail), f)","List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","List.cons(f(head), map[T, U](tail, f)) != map[T, U](List.cons(head, tail), f) or f(head) != f(item)","f(head) != f(item)"]}
{"goal":"p(List.cons(head, tail))","proof":["not f(item) ∈ map[T, U](List.cons(head, tail), f) or p(List.cons(head, tail))","not item ∈ tail or not p(tail) or f(item) ∈ map[T, U](tail, f)","List.cons(head, tail) != List.cons(head, tail) or List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","not f(item) ∈ map[T, U](tail, f) or List.cons(f(head), map[T, U](tail, f)) != List.cons(f(head), map[T, U](tail, f)) or f(item) ∈ List.cons(f(head), map[T, U](tail, f)) or f(head) = f(item)","not item ∈ List.cons(head, tail) or List.cons(head, tail) != List.cons(head, tail) or item ∈ tail or head = item","List.cons(f(head), map[T, U](tail, f)) != List.cons(f(head), map[T, U](tail, f)) or f(head) != f(item) or f(item) ∈ List.cons(f(head), map[T, U](tail, f))","not f(item) ∈ map[T, U](List.cons(head, tail), f)","f(head) != f(item) or f(item) ∈ List.cons(f(head), map[T, U](tail, f))","not item ∈ List.cons(head, tail) or item ∈ tail or head = item","item ∈ tail","not f(item) ∈ map[T, U](tail, f) or f(item) ∈ List.cons(f(head), map[T, U](tail, f)) or f(head) = f(item)","List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)","f(item) ∈ map[T, U](tail, f)","not f(item) ∈ List.cons(f(head), map[T, U](tail, f))","f(head) != f(item)","f(head) = f(item)"]}
{"goal":"p(List.cons(head, tail))","proof":["item ∈ List.cons(head, tail) or p(List.cons(head, tail))","not f(item) ∈ map[T, U](List.cons(head, tail), f) or p(List.cons(head, tail))","List.cons(item, tail) != List.cons(item, tail) or List.cons(f(item), map[T, U](tail, f)) = map[T, U](List.cons(item, tail), f)","item ∈ List.cons(head, tail)","head = item","List.cons(f(item), map[T, U](tail, f)) != List.cons(f(item), map[T, U](tail, f)) or f(item) != f(item) or f(item) ∈ List.cons(f(item), map[T, U](tail, f))","not f(item) ∈ map[T, U](List.cons(head, tail), f)","f(item) != f(item) or f(item) ∈ List.cons(f(item), map[T, U](tail, f))","List.cons(f(item), map[T, U](tail, f)) = map[T, U](List.cons(item, tail), f)","f(item) ∈ List.cons(f(item), map[T, U](tail, f))","not f(item) ∈ map[T, U](List.cons(item, tail), f)"]}
{"goal":"map_preimage_contains","proof":["let (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x1) } }","not p(List.nil[T]) or p(s1) or p(s1)","p(s1) or p(s1)","not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(list)","not p(List.cons(s0, s1)) or p(list)","not p(s1) or p(List.cons(s0, s1))","not item ∈ list or not p(list) or f(item) ∈ map[T, U](list, f)","p(s1)","not p(list)","not p(List.cons(s0, s1))"]}
{"goal":"p(List.nil[T])","proof":["not map[T, U](List.nil[T], f).is_unique or p(List.nil[T])","List.nil[U].unique != List.nil[U] or List.nil[U].is_unique","map[T, U](List.nil[T], f) = List.nil[U]"]}
{"goal":"not map[T, U](tail, f).is_unique","proof":["let s0: List[U] -> U satisfy { forall(x0: List[U]) { not has_duplicate(x0) or x0.count(s0(x0)) > 1 } and forall(x1: List[U], x2: U) { not x1.count(x2) > 1 or has_duplicate(x1) } }","not has_duplicate(tail_map) or tail_map.count(s0(tail_map)) > 1","not tail_map.is_unique or tail_map.count(s0(tail_map)) <= 1","tail_map.count(s0(tail_map)) > 1 = 1 < tail_map.count(s0(tail_map))","not tail_map.count(s0(tail_map)) <= 1 or not 1 < tail_map.count(s0(tail_map))"]}
{"goal":"tail_map.contains(dup)","proof":["let s0: List[U] -> U satisfy { forall(x0: List[U]) { x0.count(s0(x0)) > 1 or x0.is_unique } }","not tail_map.count(s0(tail_map)) > 1 or has_duplicate(tail_map)","List.cons(dup, tail_map) != List.cons(dup, tail_map) or List.cons(dup, tail_map).unique = List.cons(dup, tail_map.unique) or dup ∈ tail_map","tail_map.count(s0(tail_map)) > 1 or tail_map.is_unique","map[T, U](List.cons(head, tail), f).unique != map[T, U](List.cons(head, tail), f) or map[T, U](List.cons(head, tail), f).is_unique","not tail_map.is_unique or tail_map.unique = tail_map","List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)"]}
{"goal":"exists(k0: T) { tail.contains(k0) and f(k0) = dup }","proof":["let s0: (List[T], T -> U, U) -> T satisfy { forall(x0: List[T], x1: T -> U, x2: U) { not x2 ∈ map[T, U](x0, x1) or s0(x0, x1, x2) ∈ x0 } and forall(x3: List[T], x4: T -> U, x5: U) { not x5 ∈ map[T, U](x3, x4) or x4(s0(x3, x4, x5)) = x5 } }","not s0(tail, f, dup) ∈ tail or f(s0(tail, f, dup)) != dup","not dup ∈ map[T, U](tail, f) or f(s0(tail, f, dup)) = dup","not dup ∈ map[T, U](tail, f) or s0(tail, f, dup) ∈ tail"]}
{"goal":"p(List.cons(head, tail))","proof":["let s0: T satisfy { s0 ∈ tail and f(s0) = dup }","let s1: List[U] -> U satisfy { forall(x0: List[U]) { x0.count(s1(x0)) > 1 or x0.is_unique } }","f(s0) != f(x) or p(List.cons(head, tail)) or s0 = x","f(x) != f(head) or p(List.cons(head, tail)) or x = head","not s0 ∈ tail or List.cons(s0, tail) != List.cons(s0, tail) or List.cons(s0, tail).unique = tail.unique","not List.cons(head, tail).is_unique or tail.is_unique","not List.cons(head, tail).is_unique or List.cons(head, tail).unique = List.cons(head, tail)","not tail.is_unique or tail.unique = tail"]}
{"goal":"p(List.cons(head, tail))","proof":["let (s0: List[T] -> T, s1: List[T] -> T) satisfy { forall(x0: List[T]) { s1(x0) != s0(x0) or not x0.is_unique or not p(x0) or map[T, U](x0, f).is_unique } and forall(x1: List[T]) { not x1.is_unique or not p(x1) or map[T, U](x1, f).is_unique or f(s1(x1)) = f(s0(x1)) } and forall(x2: List[T]) { x2.is_unique or p(x2) } and forall(x3: List[T]) { not map[T, U](x3, f).is_unique or p(x3) } and forall(x4: T, x5: T, x6: List[T]) { f(x4) != f(x5) or p(x6) or x4 = x5 } }","f(s1(tail)) != f(s0(tail)) or p(List.cons(head, tail)) or s1(tail) = s0(tail)","s1(tail) != s0(tail) or not tail.is_unique or not p(tail) or map[T, U](tail, f).is_unique","not tail.is_unique or not p(tail) or map[T, U](tail, f).is_unique or f(s1(tail)) = f(s0(tail))","not List.cons(head, tail).is_unique or tail.is_unique"]}
{"goal":"p(List.cons(head, tail))","proof":["List.cons(head, tail).is_unique or p(List.cons(head, tail))","not map[T, U](List.cons(head, tail), f).is_unique or p(List.cons(head, tail))"]}
{"goal":"pigeonhole_unique_map","proof":["let (s0: List[T] -> T, s1: List[T] -> T) satisfy { forall(x0: List[T]) { s1(x0) != s0(x0) or not x0.is_unique or not p(x0) or map[T, U](x0, f).is_unique } and forall(x1: List[T]) { not x1.is_unique or not p(x1) or map[T, U](x1, f).is_unique or f(s1(x1)) = f(s0(x1)) } and forall(x2: List[T]) { x2.is_unique or p(x2) } and forall(x3: List[T]) { not map[T, U](x3, f).is_unique or p(x3) } and forall(x4: T, x5: T, x6: List[T]) { f(x4) != f(x5) or p(x6) or x4 = x5 } }","f(s1(items)) != f(s0(items)) or s1(items) = s0(items)","let (s2: (List[T] -> Bool) -> T, s3: (List[T] -> Bool) -> List[T]) satisfy { forall(x7: List[T] -> Bool, x8: List[T]) { not x7(List.nil[T]) or x7(s3(x7)) or x7(x8) } and forall(x9: List[T] -> Bool, x10: List[T]) { not x9(List.cons(s2(x9), s3(x9))) or not x9(List.nil[T]) or x9(x10) } }","not p(s3(p)) or p(List.cons(s2(p), s3(p)))","s1(items) != s0(items) or not items.is_unique or not p(items) or map[T, U](items, f).is_unique","not items.is_unique or not p(items) or map[T, U](items, f).is_unique or f(s1(items)) = f(s0(items))","not p(List.cons(s2(p), s3(p))) or not p(List.nil[T]) or p(items)","not p(List.nil[T]) or p(s3(p)) or p(s3(p))"]}
{"goal":"not map[T, U](items, f).is_unique","proof":["map[T, U](items, f).length = items.length","items.length > items.length = items.length < items.length","not map[T, U](items, f).is_unique or map[T, U](items, f).unique = map[T, U](items, f)","not items.length < items.length"]}
{"goal":"pigeonhole_map","proof":["let (s0: (List[T], T -> U) -> T, s1: (List[T], T -> U) -> T) satisfy { forall(x0: List[T], x1: T -> U) { s1(x0, x1) != s0(x0, x1) or not x0.is_unique or map[T, U](x0, x1).is_unique } and forall(x2: List[T], x3: T -> U) { not x2.is_unique or map[T, U](x2, x3).is_unique or x3(s1(x2, x3)) = x3(s0(x2, x3)) } }","f(s1(items, f)) != f(s0(items, f)) or s1(items, f) = s0(items, f)","not items.is_unique or map[T, U](items, f).is_unique or f(s1(items, f)) = f(s0(items, f))","s1(items, f) != s0(items, f) or not items.is_unique or map[T, U](items, f).is_unique"]}
{"goal":"tail_cancels_cons","proof":["List.cons(a, b) != List.cons(a, b) or List.cons(a, b).tail = b"]}
{"goal":"drop_zero","proof":["0 != 0 or a.drop(0) = a"]}
{"goal":"drop_one","proof":["0.suc != 1 or a.tail.drop(0) = a.drop(1)","a.tail.drop(0) = a.tail"]}
{"goal":"p(List.nil[T])","proof":["(List.nil[T] + b).drop(List.nil[T].length) != b or p(List.nil[T])","List.nil[T].length != 0 or b.drop(List.nil[T].length) = b","List.nil[T] + b = b"]}
{"goal":"p(List.cons(head, tail))","proof":["(List.cons(head, tail) + b).drop(List.cons(head, tail).length) != b or p(List.cons(head, tail))","not p(tail) or (tail + b).drop(tail.length) = b","List.cons(head, tail + b).tail = tail + b","List.cons(head, tail).length = tail.length.suc","List.cons(head, tail + b).tail.drop(tail.length) = List.cons(head, tail + b).drop(tail.length.suc)","List.cons(head, tail) + b = List.cons(head, tail + b)"]}
{"goal":"drop_cancels_add","proof":["let (s0: (List[T] -> Bool) -> T, s1: (List[T] -> Bool) -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not p(a) or (a + b).drop(a.length) = b","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(a)","not p(List.nil[T]) or p(s1(p)) or p(a)"]}
{"goal":"f(0)","proof":["let (s0: Nat -> List[T], s1: Nat -> Nat) satisfy { forall(x0: Nat, x1: List[T], x2: Nat) { not f(x0) or x1.drop(x0).drop(x2) = x1.drop(x0 + x2) } and forall(x3: Nat) { s0(x3).drop(x3).drop(s1(x3)) != s0(x3).drop(x3 + s1(x3)) or f(x3) } }","s0(0).drop(0).drop(s1(0)) != s0(0).drop(0 + s1(0)) or f(0)","s0(0).drop(0) = s0(0)","0 + s1(0) = s1(0)"]}
{"goal":"l.drop(x.suc).drop(k) = l.drop(x.suc + k)","proof":["not f(x) or l.tail.drop(x).drop(k) = l.tail.drop(x + k)","x.suc + k = (x + k).suc","l.tail.drop(x + k) = l.drop((x + k).suc)","l.tail.drop(x) = l.drop(x.suc)"]}
{"goal":"drop_twice","proof":["let s0: Nat satisfy { forall(x0: Nat) { not f(0) or f(s0) or f(x0) } and forall(x1: Nat) { not f(s0.suc) or not f(0) or f(x1) } }","not f(0) or f(s0) or f(s0)","not f(s0.suc) or not f(0) or f(m)","not f(m) or a.drop(m).drop(n) = a.drop(m + n)","let (s1: Nat -> List[T], s2: Nat -> Nat) satisfy { forall(x2: Nat, x3: List[T], x4: Nat) { not f(x2) or x3.drop(x2).drop(x4) = x3.drop(x2 + x4) } and forall(x5: Nat) { s1(x5).drop(x5).drop(s2(x5)) != s1(x5).drop(x5 + s2(x5)) or f(x5) } }","not f(s0) or s1(s0.suc).drop(s0.suc).drop(s2(s0.suc)) = s1(s0.suc).drop(s0.suc + s2(s0.suc))","s1(s0.suc).drop(s0.suc).drop(s2(s0.suc)) != s1(s0.suc).drop(s0.suc + s2(s0.suc)) or f(s0.suc)"]}
{"goal":"q(List.cons(head, tail))","proof":["List.cons(head, tail).drop_last(0) != List.cons(head, tail) or q(List.cons(head, tail))","not q(tail) or tail.drop_last(0) = tail","not tail.length < 0","List.cons(head, tail).drop_last(0) = List.cons(head, tail.drop_last(0)) or tail.length < 0"]}
{"goal":"drop_last_zero","proof":["let (s0: (List[T] -> Bool) -> T, s1: (List[T] -> Bool) -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","not q(s1(q)) or q(List.cons(s0(q), s1(q)))","List.nil[T].drop_last(0) != List.nil[T] or q(List.nil[T])","not q(a) or a.drop_last(0) = a","not q(List.cons(s0(q), s1(q))) or not q(List.nil[T]) or q(a)","not q(List.nil[T]) or q(s1(q)) or q(a)","List.nil[T].drop_last(0) = List.nil[T]"]}
{"goal":"r(List.cons(head, tail))","proof":["List.cons(head, tail).drop_last(List.cons(head, tail).length) != List.nil[T] or r(List.cons(head, tail))","tail.length < tail.length.suc","List.cons(head, tail).length = tail.length.suc","not tail.length < tail.length.suc or List.cons(head, tail).drop_last(tail.length.suc) = List.nil[T]"]}
{"goal":"drop_last_all","proof":["let (s0: (List[T] -> Bool) -> T, s1: (List[T] -> Bool) -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","not r(s1(r)) or r(List.cons(s0(r), s1(r)))","List.nil[T].drop_last(List.nil[T].length) != List.nil[T] or r(List.nil[T])","not r(l) or l.drop_last(l.length) = List.nil[T]","not r(List.cons(s0(r), s1(r))) or not r(List.nil[T]) or r(l)","not r(List.nil[T]) or r(s1(r)) or r(l)","List.nil[T].drop_last(List.nil[T].length) = List.nil[T]"]}
{"goal":"List.cons(head, tail + b).drop_last(b.length) = List.cons(head, (tail + b).drop_last(b.length))","proof":["List.cons(head, tail + b) != List.cons(head, tail + b) or List.cons(head, tail + b).drop_last(b.length) = List.cons(head, (tail + b).drop_last(b.length)) or (tail + b).length < b.length","tail.length + b.length = (tail + b).length","not b.length <= b.length + tail.length or not b.length + tail.length < b.length","tail.length + b.length = b.length + tail.length","b.length <= b.length + tail.length"]}
{"goal":"p(List.cons(head, tail))","proof":["(List.cons(head, tail) + b).drop_last(b.length) != List.cons(head, tail) or p(List.cons(head, tail))","not p(tail) or (tail + b).drop_last(b.length) = tail","List.cons(head, tail) + b = List.cons(head, tail + b)"]}
{"goal":"drop_last_cancels_add","proof":["let (s0: (List[T] -> Bool) -> T, s1: (List[T] -> Bool) -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","not p(s1(p)) or p(List.cons(s0(p), s1(p)))","(List.nil[T] + b).drop_last(b.length) != List.nil[T] or p(List.nil[T])","not p(a) or (a + b).drop_last(b.length) = a","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(a)","not p(List.nil[T]) or p(s1(p)) or p(a)","List.nil[T] + b = b"]}
{"goal":"zero_until","proof":["n.range.drop(0) = 0.until(n)"]}
{"goal":"until_self","proof":["n.range.drop(n) = n.until(n)","n.range + List.nil[Nat] = n.range","n.range.length = n"]}
{"goal":"until_suc","proof":["n.range + List.singleton(n) = n.range.append(n)","n.suc.range.drop(n) = n.until(n.suc)","n.range.length = n","n.range.append(n) = n.suc.range"]}
{"goal":"zero_upto","proof":["0.until(n.suc) = 0.upto(n)","0.until(n.suc) = n.suc.range"]}
{"goal":"upto_self","proof":["n.until(n.suc) = n.upto(n)","n.until(n.suc) = List.singleton(n)"]}
{"goal":"exists(k0: Nat) { a + k0 = b }","proof":["let s0: (Nat, Nat) -> Nat satisfy { forall(x0: Nat, x1: Nat) { not x0 <= x1 or x0 + s0(x0, x1) = x1 } and forall(x2: Nat, x3: Nat, x4: Nat) { x2 + x3 != x4 or x2 <= x4 } }","a + s0(a, b) != b","not a <= b or a + s0(a, b) = b"]}
{"goal":"f(0)","proof":["a.range + a.until(a + 0) != (a + 0).range or f(0)","a.range + List.nil[Nat] = a.range","a + 0 = a"]}
{"goal":"f(x.suc)","proof":["a.range + a.until(a + x.suc) != (a + x.suc).range or f(x.suc)","not f(x) or a.range + a.until(a + x) = (a + x).range","a + x.suc = (a + x).suc","a.range + a.until(a + x) + List.singleton(a + x) = (a.range + a.until(a + x)).append(a + x)","(a + x.suc).range.drop(a) = a.until(a + x.suc)","a.range.length = a","(a + x).range.append(a + x) = (a + x).suc.range"]}
{"goal":"f(k)","proof":["let s0: (Nat -> Bool) -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(s0(x2).suc) or not x2(0) or x2(x3) } }","not f(s0(f)) or f(s0(f).suc)","not f(s0(f).suc) or not f(0) or f(k)","not f(0) or f(s0(f)) or f(k)"]}
{"goal":"range_add_until","proof":["not f(k) or a.range + a.until(a + k) = (a + k).range"]}
{"goal":"m >= max_list(tail)","proof":["head.max(k) >= k"]}
{"goal":"tail.contains(x) implies x <= m","proof":["not x ∈ tail or not f(tail) or x <= max_list(tail)","not lib(util).is_transitive[Nat](Nat.lte) or not x <= max_list(tail) or not max_list(tail) <= m or x <= m","max_list(tail) <= m = m >= max_list(tail)"]}
{"goal":"List.cons(head, tail).contains(x) implies x <= m","proof":["List.cons(head, tail) != List.cons(head, tail) or not x ∈ List.cons(head, tail) or x ∈ tail or x = head","x <= m = m >= x","head.max(k) >= head"]}
{"goal":"f(List.cons(head, tail))","proof":["let s0: List[Nat] -> Nat satisfy { forall(x0: List[Nat], x1: Nat) { not x1 ∈ x0 or not f(x0) or x1 <= max_list(x0) } and forall(x2: List[Nat]) { s0(x2) ∈ x2 or f(x2) } and forall(x3: List[Nat]) { not s0(x3) <= max_list(x3) or f(x3) } }","s0(List.cons(head, tail)) ∈ List.cons(head, tail) or f(List.cons(head, tail))","not s0(List.cons(head, tail)) <= max_list(List.cons(head, tail)) or f(List.cons(head, tail))","not s0(List.cons(head, tail)) ∈ List.cons(head, tail) or s0(List.cons(head, tail)) <= m","head.max(max_list(tail)) = max_list(List.cons(head, tail))"]}
{"goal":"f(list)","proof":["let (s0: (List[Nat] -> Bool) -> Nat, s1: (List[Nat] -> Bool) -> List[Nat]) satisfy { forall(x0: List[Nat] -> Bool, x1: List[Nat]) { not x0(List.nil[Nat]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[Nat] -> Bool, x3: List[Nat]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[Nat]) or x2(x3) } }","not f(s1(f)) or f(List.cons(s0(f), s1(f)))","let s2: List[Nat] -> Nat satisfy { forall(x4: List[Nat], x5: Nat) { not x5 ∈ x4 or not f(x4) or x5 <= max_list(x4) } and forall(x6: List[Nat]) { s2(x6) ∈ x6 or f(x6) } and forall(x7: List[Nat]) { not s2(x7) <= max_list(x7) or f(x7) } }","s2(List.nil[Nat]) ∈ List.nil[Nat] or f(List.nil[Nat])","not f(List.cons(s0(f), s1(f))) or not f(List.nil[Nat]) or f(list)","not f(List.nil[Nat]) or f(s1(f)) or f(list)","not s2(List.nil[Nat]) ∈ List.nil[Nat]"]}
{"goal":"list_has_max","proof":["let s0: Nat satisfy { s0 ∈ list and not s0 <= n }","not s0 ∈ list or not f(list) or s0 <= max_list(list)","not s0 <= max_list(list) or not max_list(list) <= n or s0 <= n"]}
{"goal":"no_list_contains_nat","proof":["max_list(list).suc ∈ list","not max_list(list) <= max_list(list) or not max_list(list).suc ∈ list or max_list(list).suc <= max_list(list)","not max_list(list).suc <= max_list(list) or not max_list(list) < max_list(list).suc","max_list(list) < max_list(list).suc","max_list(list) <= max_list(list)"]}
{"goal":"p(List.cons(head, tail))","proof":["not List.cons(head, tail).find_first_idx(item) < List.cons(head, tail).length or p(List.cons(head, tail))","0 < tail.length.suc or tail.length.suc < 0 or tail.length.suc = 0","not tail.length.suc < 0","tail.length.suc != 0","List.cons(head, tail).length = tail.length.suc","head != item or List.cons(head, tail).find_first_idx(item) = 0"]}
{"goal":"p(List.cons(head, tail))","proof":["not List.cons(head, tail).find_first_idx(item) < List.cons(head, tail).length or p(List.cons(head, tail))","not item ∈ tail or not p(tail) or tail.find_first_idx(item) < tail.length","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).find_first_idx(item) = 1 + tail.find_first_idx(item) or head = item","not item ∈ List.cons(head, tail) or List.cons(head, tail) != List.cons(head, tail) or item ∈ tail or head = item","not tail.length.suc <= tail.find_first_idx(item).suc or tail.length <= tail.find_first_idx(item)","not tail.length <= tail.find_first_idx(item) or not tail.find_first_idx(item) < tail.length","tail.length.suc <= tail.find_first_idx(item).suc or tail.find_first_idx(item).suc < tail.length.suc","1 + tail.find_first_idx(item) = tail.find_first_idx(item).suc","List.cons(head, tail).length = tail.length.suc"]}
{"goal":"find_first_idx_contains","proof":["let (s0: (List[T] -> Bool) -> T, s1: (List[T] -> Bool) -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","item ∈ List.cons(s0(p), s1(p)) or p(List.cons(s0(p), s1(p)))","item ∈ List.nil[T] or p(List.nil[T])","not item ∈ List.cons(s0(p), s1(p)) or not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not item ∈ list or not p(list) or list.find_first_idx(item) < list.length","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(list)","not p(List.nil[T]) or p(s1(p)) or p(list)","not item ∈ List.nil[T]"]}
{"goal":"p(List.cons(head, tail))","proof":["List.cons(head, tail).get_idx(List.cons(head, tail).find_first_idx(item)) != Option.some(item) or p(List.cons(head, tail))","List.cons(head, tail).find_first_idx(item) > 0 = 0 < List.cons(head, tail).find_first_idx(item)","not 0 < List.cons(head, tail).find_first_idx(item) or List.cons(head, tail).find_first_idx(item) != 0","head != item or List.cons(head, tail).find_first_idx(item) = 0","List.cons(item, tail).get_idx(List.cons(head, tail).find_first_idx(item)) = Option.some(item) or List.cons(head, tail).find_first_idx(item) > 0"]}
{"goal":"List.cons(head, tail).get_idx(1 + idx) = tail.get_idx(idx)","proof":["0 < idx.suc or idx.suc < 0 or idx.suc = 0","idx.suc > 0 = 0 < idx.suc","idx.suc - 1 = idx","1 + idx = idx.suc","not idx.suc < 0","idx.suc != 0","not idx.suc > 0 or tail.get_idx(idx.suc - 1) = List.cons(head, tail).get_idx(idx.suc)"]}
{"goal":"p(List.cons(head, tail))","proof":["List.cons(head, tail).get_idx(List.cons(head, tail).find_first_idx(item)) != Option.some(item) or p(List.cons(head, tail))","not item ∈ tail or not p(tail) or tail.get_idx(tail.find_first_idx(item)) = Option.some(item)","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).find_first_idx(item) = 1 + tail.find_first_idx(item) or head = item","not item ∈ List.cons(head, tail) or List.cons(head, tail) != List.cons(head, tail) or item ∈ tail or head = item"]}
{"goal":"find_first_idx_get_idx","proof":["let (s0: (List[T] -> Bool) -> T, s1: (List[T] -> Bool) -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","item ∈ List.cons(s0(p), s1(p)) or p(List.cons(s0(p), s1(p)))","item ∈ List.nil[T] or p(List.nil[T])","not item ∈ List.cons(s0(p), s1(p)) or not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not item ∈ list or not p(list) or list.get_idx(list.find_first_idx(item)) = Option.some(item)","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(list)","not p(List.nil[T]) or p(s1(p)) or p(list)","not item ∈ List.nil[T]"]}
{"goal":"p(List.nil[T])","proof":["i + 1 < List.nil[T].length or p(List.nil[T])","not i + 1 < 0"]}
{"goal":"List.cons(head, tail).get_idx(i + 1) = tail.get_idx(i)","proof":["0 < i.suc or i.suc < 0 or i.suc = 0","i + 1 > 0 = 0 < i + 1","i + 1 - 1 = i","i + 1 = i.suc","not i.suc < 0","i.suc != 0","not i + 1 > 0 or List.cons(head, tail).get_idx(i + 1) = tail.get_idx(i + 1 - 1)"]}
{"goal":"p(List.cons(head, tail))","proof":["List.cons(head, tail).get_idx(i + 1) != List.cons(head, tail).tail.get_idx(i) or p(List.cons(head, tail))","List.cons(head, tail).tail = tail"]}
{"goal":"get_idx_succ_implies_tail","proof":["let (s0: (List[T] -> Bool) -> T, s1: (List[T] -> Bool) -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","i + 1 < List.cons(s0(p), s1(p)).length or p(List.cons(s0(p), s1(p)))","not i + 1 < List.cons(s0(p), s1(p)).length or not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not i + 1 < list.length or not p(list) or list.get_idx(i + 1) = list.tail.get_idx(i)","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(list)","not p(List.nil[T]) or p(s1(p)) or p(list)"]}
{"goal":"p(List.nil[T])","proof":["List.nil[T].count(item) > 1 or p(List.nil[T])","List.nil[T].count(item) > 1 = 1 < List.nil[T].count(item)","not 1 < 0","List.nil[T].count(item) = 0"]}
{"goal":"tail.contains(item)","proof":["tail.count(item) = 0 or item ∈ tail","List.cons(head, tail).count(item) > 1 = 1 < List.cons(head, tail).count(item)","not 1 < List.cons(head, tail).count(item) or List.cons(head, tail).count(item) != 1","1 + 0 = 1","List.cons(item, tail).count(item) = 1 + tail.count(item)"]}
{"goal":"idx + 1 < tail.length + 1","proof":["not idx < tail.length or 1 + idx < 1 + tail.length","not item ∈ tail or tail.find_first_idx(item) < tail.length","idx + 1 = 1 + idx","tail.length + 1 = 1 + tail.length"]}
{"goal":"List.cons(head, tail).get_idx(idx + 1) = tail.get_idx(idx)","proof":["not item ∈ tail or tail.get_idx(tail.find_first_idx(item)) = Option.some(item)","idx + 1 - 1 = idx","List.cons(item, tail).get_idx(idx + 1) = Option.some(item) or idx + 1 > 0","not idx + 1 > 0 or List.cons(head, tail).get_idx(idx + 1) = tail.get_idx(idx + 1 - 1)"]}
{"goal":"0 < j","proof":["0 < 0 + idx.suc","idx + 1 = idx.suc","0 + idx.suc = idx.suc"]}
{"goal":"List.cons(head, tail).get_idx(0) = Option.some(head)","proof":["List.cons(head, tail) != List.cons(head, tail) or 0 > 0 or List.cons(head, tail).get_idx(0) = Option.some(head)","0 > 0 = 0 < 0","not 0 < 0"]}
{"goal":"p(List.cons(head, tail))","proof":["List.cons(head, tail).get_idx(0) != Option.some(item) or List.cons(head, tail).get_idx(j) != Option.some(item) or not j < List.cons(head, tail).length or not 0 < j or p(List.cons(head, tail))","not item ∈ tail or tail.get_idx(tail.find_first_idx(item)) = Option.some(item)","tail.length + 1 = tail.length.suc","List.cons(head, tail).length = tail.length.suc"]}
{"goal":"exists(k0: Nat, k1: Nat) { k0 < k1 and k1 < tail.length and tail.get_idx(k0) = Option.some(item) and tail.get_idx(k1) = Option.some(item) }","proof":["let (s0: List[T] -> Nat, s1: List[T] -> Nat) satisfy { forall(x0: List[T]) { not x0.count(item) > 1 or not p(x0) or s0(x0) < s1(x0) } and forall(x1: List[T]) { not x1.count(item) > 1 or not p(x1) or s1(x1) < x1.length } and forall(x2: List[T]) { not x2.count(item) > 1 or not p(x2) or x2.get_idx(s0(x2)) = Option.some(item) } and forall(x3: List[T]) { not x3.count(item) > 1 or not p(x3) or x3.get_idx(s1(x3)) = Option.some(item) } and forall(x4: List[T]) { x4.count(item) > 1 or p(x4) } and forall(x5: List[T], x6: Nat, x7: Nat) { Option.some(item) != x5.get_idx(x6) or Option.some(item) != x5.get_idx(x7) or not x7 < x5.length or not x6 < x7 or p(x5) } }","not s1(tail) < tail.length or tail.get_idx(s0(tail)) != Option.some(item) or tail.get_idx(s1(tail)) != Option.some(item) or not s0(tail) < s1(tail)","not tail.count(item) > 1 or not p(tail) or s1(tail) < tail.length","not tail.count(item) > 1 or not p(tail) or s0(tail) < s1(tail)","not tail.count(item) > 1 or not p(tail) or tail.get_idx(s1(tail)) = Option.some(item)","not tail.count(item) > 1 or not p(tail) or tail.get_idx(s0(tail)) = Option.some(item)","List.cons(head, tail) != List.cons(head, tail) or List.cons(head, tail).count(item) = tail.count(item) or head = item"]}
{"goal":"i + 1 > 0","proof":["i.suc > 0 = 0 < i.suc","0 < 0 + i.suc","i + 1 = 1 + i","1 + i = i.suc","0 + i.suc = i.suc"]}
{"goal":"List.cons(head, tail).get_idx(i + 1) = tail.get_idx(i)","proof":["i + 1 - 1 = i","not i + 1 > 0 or tail.get_idx(i + 1 - 1) = List.cons(head, tail).get_idx(i + 1)"]}
{"goal":"j + 1 > 0","proof":["j.suc > 0 = 0 < j.suc","0 < 0 + j.suc","j + 1 = 1 + j","1 + j = j.suc","0 + j.suc = j.suc"]}
{"goal":"List.cons(head, tail).get_idx(j + 1) = tail.get_idx(j)","proof":["j + 1 - 1 = j","not j + 1 > 0 or tail.get_idx(j + 1 - 1) = List.cons(head, tail).get_idx(j + 1)"]}
{"goal":"i + 1 < j + 1","proof":["not i < j or 1 + i < 1 + j","i + 1 = 1 + i","j + 1 = 1 + j"]}
{"goal":"p(List.cons(head, tail))","proof":["List.cons(head, tail).get_idx(i + 1) != Option.some(item) or List.cons(head, tail).get_idx(j + 1) != Option.some(item) or not j + 1 < List.cons(head, tail).length or not i + 1 < j + 1 or p(List.cons(head, tail))","not tail.length.suc <= j.suc or tail.length <= j","not tail.length <= j or not j < tail.length","tail.length.suc <= j.suc or j.suc < tail.length.suc","j + 1 = j.suc","List.cons(head, tail).length = tail.length.suc"]}
{"goal":"p(list)","proof":["let (s0: (List[T] -> Bool) -> T, s1: (List[T] -> Bool) -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","List.cons(s0(p), s1(p)).count(item) > 1 or p(List.cons(s0(p), s1(p)))","not List.cons(s0(p), s1(p)).count(item) > 1 or not p(s1(p)) or p(List.cons(s0(p), s1(p)))","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(list)","not p(List.nil[T]) or p(s1(p)) or p(list)"]}
{"goal":"duplicate_implies_duplicate_idx","proof":["let (s0: List[T] -> Nat, s1: List[T] -> Nat) satisfy { forall(x0: List[T]) { not x0.count(item) > 1 or not p(x0) or s0(x0) < s1(x0) } and forall(x1: List[T]) { not x1.count(item) > 1 or not p(x1) or s1(x1) < x1.length } and forall(x2: List[T]) { not x2.count(item) > 1 or not p(x2) or x2.get_idx(s0(x2)) = Option.some(item) } and forall(x3: List[T]) { not x3.count(item) > 1 or not p(x3) or x3.get_idx(s1(x3)) = Option.some(item) } and forall(x4: List[T]) { x4.count(item) > 1 or p(x4) } and forall(x5: List[T], x6: Nat, x7: Nat) { Option.some(item) != x5.get_idx(x6) or Option.some(item) != x5.get_idx(x7) or not x7 < x5.length or not x6 < x7 or p(x5) } }","not s1(list) < list.length or list.get_idx(s0(list)) != Option.some(item) or list.get_idx(s1(list)) != Option.some(item) or not s0(list) < s1(list)","not list.count(item) > 1 or not p(list) or s1(list) < list.length","not list.count(item) > 1 or not p(list) or s0(list) < s1(list)","not list.count(item) > 1 or not p(list) or list.get_idx(s1(list)) = Option.some(item)","not list.count(item) > 1 or not p(list) or list.get_idx(s0(list)) = Option.some(item)"]}
{"goal":"index_pigeonhole","proof":["let (s0: (List[T], T) -> Nat, s1: (List[T], T) -> Nat) satisfy { forall(x0: List[T], x1: T) { not x0.count(x1) > 1 or s0(x0, x1) < s1(x0, x1) } and forall(x2: List[T], x3: T) { not x2.count(x3) > 1 or s1(x2, x3) < x2.length } and forall(x4: List[T], x5: T) { not x4.count(x5) > 1 or x4.get_idx(s0(x4, x5)) = Option.some(x5) } and forall(x6: List[T], x7: T) { not x6.count(x7) > 1 or x6.get_idx(s1(x6, x7)) = Option.some(x7) } }","let s2: List[T] -> T satisfy { forall(x8: List[T]) { not x8.unique.length < x8.length or x8.count(s2(x8)) > 1 } }","not s1(list, s2(list)) < list.length or list.get_idx(s1(list, s2(list))) != list.get_idx(s0(list, s2(list))) or not s0(list, s2(list)) < s1(list, s2(list))","not list.count(s2(list)) > 1 or list.get_idx(s1(list, s2(list))) = Option.some(s2(list))","not list.count(s2(list)) > 1 or list.get_idx(s0(list, s2(list))) = Option.some(s2(list))","not list.count(s2(list)) > 1 or s0(list, s2(list)) < s1(list, s2(list))","not list.unique.length < list.length or list.count(s2(list)) > 1","not list.count(s2(list)) > 1 or s1(list, s2(list)) < list.length"]}
{"goal":"pl(0, l)","proof":["l.get_idx(0) != Option.some(head) or pl(0, l)","List.cons(head, tail) != l or 0 > 0 or l.get_idx(0) = Option.some(head)","let s0: Nat satisfy { true }","not 0 > 0 or 0 - 1 - s0 < 0","not 0 - 1 - s0 < 0"]}
{"goal":"p(0)","proof":["let s0: Nat -> List[T] satisfy { forall(x0: Nat, x1: List[T]) { not p(x0) or pl(x0, x1) } and forall(x2: Nat) { not pl(x2, s0(x2)) or p(x2) } }","pl(0, s0(0)) or s0(0) = List.nil[T]","not pl(0, s0(0)) or p(0)","0 < s0(0).length or pl(0, s0(0))","not 0 < s0(0).length or s0(0).length != 0"]}
{"goal":"i + 1 < l.length","proof":["l.length <= i + 1 = i + 1 >= l.length","l.length <= i + 1 or i + 1 < l.length"]}
{"goal":"exists(k0: T) { tail.get_idx(i) = Option.some(k0) }","proof":["let s0: (Nat, List[T]) -> T satisfy { forall(x0: Nat, x1: List[T]) { not x0 < x1.length or not pl(x0, x1) or Option.some(s0(x0, x1)) = x1.get_idx(x0) } and forall(x2: Nat, x3: List[T]) { x2 < x3.length or pl(x2, x3) } and forall(x4: List[T], x5: Nat, x6: T) { x4.get_idx(x5) != Option.some(x6) or pl(x5, x4) } }","Option.some(s0(i, tail)) != tail.get_idx(i)","not p(i) or pl(i, tail)","not i < tail.length or not pl(i, tail) or Option.some(s0(i, tail)) = tail.get_idx(i)","List.cons(head, tail) != l or tail.length.suc = l.length","not i.suc < tail.length.suc or i < tail.length","i + 1 = i.suc"]}
{"goal":"pl(i + 1, l)","proof":["l.get_idx(i + 1) != Option.some(x) or pl(i + 1, l)","not i + 1 < l.length or l.get_idx(i + 1) = l.tail.get_idx(i)","List.cons(head, tail) != l or l.tail = tail"]}
{"goal":"pl(i + 1, l)","proof":["i + 1 < l.length or pl(i + 1, l)","not i + 1 < l.length or lib(nat.nat_base).bounded_sub(i + 1, l.length) = 0","l.length <= i + 1 = i + 1 >= l.length","let s0: Nat satisfy { true }","not l.length <= i + 1 or not i + 1 < l.length","i + 1 = 1 + i","not i + 1 < l.length or i + 1 != l.length","1 + i = i.suc","i.suc - 0 = i.suc"]}
{"goal":"get_idx_always_some","proof":["let s0: (Nat, List[T]) -> T satisfy { forall(x0: Nat, x1: List[T]) { not x0 < x1.length or not pl(x0, x1) or Option.some(s0(x0, x1)) = x1.get_idx(x0) } and forall(x2: Nat, x3: List[T]) { x2 < x3.length or pl(x2, x3) } and forall(x4: List[T], x5: Nat, x6: T) { x4.get_idx(x5) != Option.some(x6) or pl(x5, x4) } }","Option.some(s0(idx, list)) != list.get_idx(idx)","not p(idx) or pl(idx, list)","let s1: (Nat -> Bool) -> Nat satisfy { forall(x7: Nat -> Bool, x8: Nat) { not x7(0) or x7(s1(x7)) or x7(x8) } and forall(x9: Nat -> Bool, x10: Nat) { not x9(s1(x9).suc) or not x9(0) or x9(x10) } }","let s2: Nat -> List[T] satisfy { forall(x11: Nat, x12: List[T]) { not p(x11) or pl(x11, x12) } and forall(x13: Nat) { not pl(x13, s2(x13)) or p(x13) } }","not pl(s1(p) + 1, s2(s1(p) + 1)) or p(s1(p) + 1)","not p(s1(p)) or pl(s1(p) + 1, s2(s1(p) + 1))","not idx < list.length or not pl(idx, list) or Option.some(s0(idx, list)) = list.get_idx(idx)","not p(s1(p).suc) or not p(0) or p(idx)","not p(0) or p(s1(p)) or p(s1(p))","s1(p) + 1 = s1(p).suc"]}
{"goal":"map[T, U](l, f).get_idx(0) = Option.some(f(head))","proof":["List.cons(head, tail) != l or List.cons(f(head), map[T, U](tail, f)) = map[T, U](l, f)","List.cons(f(head), map[T, U](tail, f)) != map[T, U](l, f) or 0 > 0 or map[T, U](l, f).get_idx(0) = Option.some(f(head))","not 0 < 0","not 0 > 0 or 0 < 0"]}
{"goal":"pf(0, l)","proof":["map[T, U](l, f).get_idx(0) != Option.some(f(head)) or l.get_idx(0) != Option.some(head) or pf(0, l)","not head ∈ l or l.get_idx(l.find_first_idx(head)) = Option.some(head)","List.cons(head, tail) != l or head ∈ l","List.cons(head, tail) != l or l.find_first_idx(head) = 0"]}
{"goal":"p(0)","proof":["let s0: Nat -> List[T] satisfy { forall(x0: Nat, x1: List[T]) { not p(x0) or pf(x0, x1) } and forall(x2: Nat) { not pf(x2, s0(x2)) or p(x2) } }","pf(0, s0(0)) or s0(0) = List.nil[T]","not pf(0, s0(0)) or p(0)","0 < s0(0).length or pf(0, s0(0))","not 0 < s0(0).length or s0(0).length != 0"]}
{"goal":"pf(i + 1, l)","proof":["i + 1 < l.length or pf(i + 1, l)","l.length <= i + 1 = i + 1 >= l.length","not l.length <= i + 1 or not i + 1 < l.length"]}
{"goal":"l.get_idx(i + 1) = tail.get_idx(i)","proof":["not i + 1 > 0 or List.cons(head, tail) != l or tail.get_idx(i + 1 - 1) = l.get_idx(i + 1)","0 < i.suc or i.suc < 0 or i.suc = 0","i + 1 > 0 = 0 < i + 1","i + 1 - 1 = i","i + 1 = i.suc","not i.suc < 0","i.suc != 0"]}
{"goal":"i < tail.length","proof":["List.cons(head, tail) != l or tail.length.suc = l.length","not i.suc < tail.length.suc or i < tail.length","l.length <= i.suc = i.suc >= l.length","l.length <= i.suc or i.suc < l.length","i + 1 = i.suc"]}
{"goal":"exists(k0: T) { tail.get_idx(i) = Option.some(k0) and map[T, U](tail, f).get_idx(i) = Option.some(f(k0)) }","proof":["let s0: (Nat, List[T]) -> T satisfy { forall(x0: Nat, x1: List[T]) { not x0 < x1.length or not pf(x0, x1) or Option.some(s0(x0, x1)) = x1.get_idx(x0) } and forall(x2: Nat, x3: List[T]) { not x2 < x3.length or not pf(x2, x3) or Option.some(f(s0(x2, x3))) = map[T, U](x3, f).get_idx(x2) } and forall(x4: Nat, x5: List[T]) { x4 < x5.length or pf(x4, x5) } and forall(x6: List[T], x7: Nat, x8: T) { map[T, U](x6, f).get_idx(x7) != Option.some(f(x8)) or x6.get_idx(x7) != Option.some(x8) or pf(x7, x6) } }","Option.some(f(s0(i, tail))) != map[T, U](tail, f).get_idx(i) or Option.some(s0(i, tail)) != tail.get_idx(i)","not p(i) or pf(i, tail)","not i < tail.length or not pf(i, tail) or Option.some(s0(i, tail)) = tail.get_idx(i)","not i < tail.length or not pf(i, tail) or Option.some(f(s0(i, tail))) = map[T, U](tail, f).get_idx(i)"]}
{"goal":"map[T, U](List.cons(head, tail), f).get_idx(i + 1) = map[T, U](tail, f).get_idx(i + 1 - 1)","proof":["not i + 1 > 0 or List.cons(f(head), map[T, U](tail, f)) != map[T, U](List.cons(head, tail), f) or map[T, U](List.cons(head, tail), f).get_idx(i + 1) = map[T, U](tail, f).get_idx(i + 1 - 1)","0 < i.suc or i.suc < 0 or i.suc = 0","i + 1 > 0 = 0 < i + 1","i + 1 = i.suc","not i.suc < 0","i.suc != 0","List.cons(f(head), map[T, U](tail, f)) = map[T, U](List.cons(head, tail), f)"]}
{"goal":"pf(i + 1, l)","proof":["map[T, U](l, f).get_idx(i + 1) != Option.some(f(x)) or l.get_idx(i + 1) != Option.some(x) or pf(i + 1, l)","i + 1 - 1 = i"]}
{"goal":"pf(i + 1, l)","proof":["i + 1 < l.length or pf(i + 1, l)","not i + 1 < 0"]}
{"goal":"pf(idx, a)","proof":["not p(idx) or pf(idx, a)","let s0: (Nat -> Bool) -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(s0(x2).suc) or not x2(0) or x2(x3) } }","let s1: Nat -> List[T] satisfy { forall(x4: Nat, x5: List[T]) { not p(x4) or pf(x4, x5) } and forall(x6: Nat) { not pf(x6, s1(x6)) or p(x6) } }","not pf(s0(p) + 1, s1(s0(p) + 1)) or p(s0(p) + 1)","not p(s0(p)) or pf(s0(p) + 1, s1(s0(p) + 1))","not p(s0(p).suc) or not p(0) or p(idx)","not p(0) or p(s0(p)) or p(idx)","s0(p) + 1 = s0(p).suc"]}
{"goal":"map_under_idx","proof":["let s0: (Nat, List[T]) -> T satisfy { forall(x0: Nat, x1: List[T]) { not x0 < x1.length or not pf(x0, x1) or Option.some(s0(x0, x1)) = x1.get_idx(x0) } and forall(x2: Nat, x3: List[T]) { not x2 < x3.length or not pf(x2, x3) or Option.some(f(s0(x2, x3))) = map[T, U](x3, f).get_idx(x2) } and forall(x4: Nat, x5: List[T]) { x4 < x5.length or pf(x4, x5) } and forall(x6: List[T], x7: Nat, x8: T) { map[T, U](x6, f).get_idx(x7) != Option.some(f(x8)) or x6.get_idx(x7) != Option.some(x8) or pf(x7, x6) } }","Option.some(f(s0(idx, a))) != map[T, U](a, f).get_idx(idx) or Option.some(s0(idx, a)) != a.get_idx(idx)","not idx < a.length or not pf(idx, a) or Option.some(s0(idx, a)) = a.get_idx(idx)","not idx < a.length or not pf(idx, a) or Option.some(f(s0(idx, a))) = map[T, U](a, f).get_idx(idx)"]}
{"goal":"(l + b).get_idx(0) = Option.some(head)","proof":["List.cons(head, tail) != l or List.cons(head, tail + b) = l + b","List.cons(head, tail + b) != l + b or 0 > 0 or (l + b).get_idx(0) = Option.some(head)","not 0 < 0","not 0 > 0 or 0 < 0"]}
{"goal":"fp(0, l)","proof":["(l + b).get_idx(0) != l.get_idx(0) or fp(0, l)","not head ∈ l or l.get_idx(l.find_first_idx(head)) = Option.some(head)","List.cons(head, tail) != l or head ∈ l","List.cons(head, tail) != l or l.find_first_idx(head) = 0"]}
{"goal":"f(0)","proof":["let s0: Nat -> List[T] satisfy { forall(x0: Nat, x1: List[T]) { not f(x0) or fp(x0, x1) } and forall(x2: Nat) { not fp(x2, s0(x2)) or f(x2) } }","fp(0, s0(0)) or s0(0) = List.nil[T]","not fp(0, s0(0)) or f(0)","0 < s0(0).length or fp(0, s0(0))","not 0 < s0(0).length or s0(0).length != 0"]}
{"goal":"List.cons(head, tail).get_idx(i + 1) = (tail + b).get_idx(i)","proof":["not f(i) or fp(i, tail)","not i < tail.length or not fp(i, tail) or (tail + b).get_idx(i) = tail.get_idx(i)","not i + 1 < l.length or l.get_idx(i + 1) = l.tail.get_idx(i)","not i.suc < tail.length.suc or i < tail.length","List.cons(head, tail) != l or l.tail = tail","i + 1 = i.suc","List.cons(head, tail).length = tail.length.suc"]}
{"goal":"i + 1 > 0","proof":["i.suc > 0 = 0 < i.suc","0 < 0 + i.suc","i + 1 = 1 + i","1 + i = i.suc","0 + i.suc = i.suc"]}
{"goal":"List.cons(head, tail + b).get_idx(i + 1) = (tail + b).get_idx(i)","proof":["i + 1 - 1 = i","not i + 1 > 0 or List.cons(head, tail + b).get_idx(i + 1) = (tail + b).get_idx(i + 1 - 1)"]}
{"goal":"fp(i + 1, l)","proof":["(l + b).get_idx(i + 1) != l.get_idx(i + 1) or fp(i + 1, l)","List.cons(head, tail) + b = List.cons(head, tail + b)"]}
{"goal":"fp(i + 1, l)","proof":["not i + 1 < 0"]}
{"goal":"f(i + 1)","proof":["let s0: Nat -> List[T] satisfy { forall(x0: Nat, x1: List[T]) { not f(x0) or fp(x0, x1) } and forall(x2: Nat) { not fp(x2, s0(x2)) or f(x2) } }","not fp(i + 1, s0(i + 1)) or f(i + 1)","i + 1 < s0(i + 1).length or fp(i + 1, s0(i + 1))","not i + 1 < s0(i + 1).length or fp(i + 1, s0(i + 1))"]}
{"goal":"append_add_idx_left","proof":["not f(n) or fp(n, a)","let s0: (Nat -> Bool) -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(s0(x2).suc) or not x2(0) or x2(x3) } }","not f(s0(f)) or f(s0(f) + 1)","not n < a.length or not fp(n, a) or (a + b).get_idx(n) = a.get_idx(n)","not f(s0(f).suc) or not f(0) or f(n)","not f(0) or f(s0(f)) or f(s0(f))","s0(f) + 1 = s0(f).suc"]}
{"goal":"f(List.nil[T])","proof":["(List.nil[T] + List.singleton(a)).get_idx(List.nil[T].length) != Option.some(a) or f(List.nil[T])","List.cons(a, List.nil[T]) != List.singleton(a) or List.nil[T].length > 0 or List.singleton(a).get_idx(List.nil[T].length) = Option.some(a)","List.nil[T].length > 0 = 0 < List.nil[T].length","not 0 < List.nil[T].length or List.nil[T].length != 0","List.cons(a, List.nil[T]) = List.singleton(a)","List.nil[T] + List.singleton(a) = List.singleton(a)"]}
{"goal":"(l + sa).get_idx(l.length) = (tail + sa).get_idx(l.length - 1)","proof":["not l.length > 0 or List.cons(head, tail + sa) != l + sa or (tail + sa).get_idx(l.length - 1) = (l + sa).get_idx(l.length)","List.cons(head, tail) != l or List.cons(head, tail + sa) = l + sa","not head ∈ l or l.find_first_idx(head) < l.length","l.length > 0 = 0 < l.length","List.cons(head, tail) != l or head ∈ l","List.cons(head, tail) != l or l.find_first_idx(head) = 0"]}
{"goal":"f(List.cons(head, tail))","proof":["(List.cons(head, tail) + List.singleton(a)).get_idx(List.cons(head, tail).length) != Option.some(a) or f(List.cons(head, tail))","not f(tail) or (tail + List.singleton(a)).get_idx(tail.length) = Option.some(a)","List.cons(head, tail) != l or tail.length.suc = l.length","tail.length.suc - 1 = tail.length"]}
{"goal":"append_add_singleton_right","proof":["let (s0: (List[T] -> Bool) -> T, s1: (List[T] -> Bool) -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","not f(s1(f)) or f(List.cons(s0(f), s1(f)))","not f(list) or (list + List.singleton(a)).get_idx(list.length) = Option.some(a)","not f(List.cons(s0(f), s1(f))) or not f(List.nil[T]) or f(list)","not f(List.nil[T]) or f(s1(f)) or f(list)"]}
{"goal":"f(0)","proof":["idx < 0 or f(0)","not idx < 0"]}
{"goal":"(m.range + List.singleton(m)).get_idx(idx) = m.range.get_idx(idx)","proof":["not idx < m.range.length or (m.range + List.singleton(m)).get_idx(idx) = m.range.get_idx(idx)","m.range.length = m"]}
{"goal":"f(m + 1)","proof":["(m + 1).range.get_idx(idx) != Option.some(idx) or f(m + 1)","not idx < m or not f(m) or m.range.get_idx(idx) = Option.some(idx)","m.range + List.singleton(m) = m.range.append(m)","m + 1 = 1 + m","1 + m = m.suc","m.range.append(m) = m.suc.range"]}
{"goal":"(m.range + List.singleton(m)).get_idx(m) = Option.some(m)","proof":["(m.range + List.singleton(m)).get_idx(m.range.length) = Option.some(m)","m.range.length = m"]}
{"goal":"f(m + 1)","proof":["(m + 1).range.get_idx(idx) != Option.some(idx) or f(m + 1)","not idx < m.suc or idx < m or m = idx","m.range + List.singleton(m) = m.range.append(m)","m + 1 = 1 + m","1 + m = m.suc","m.range.append(m) = m.suc.range"]}
{"goal":"range_idx_eq_idx","proof":["let s0: (Nat -> Bool) -> Nat satisfy { forall(x0: Nat -> Bool, x1: Nat) { not x0(0) or x0(s0(x0)) or x0(x1) } and forall(x2: Nat -> Bool, x3: Nat) { not x2(s0(x2).suc) or not x2(0) or x2(x3) } }","idx < s0(f) + 1 or f(s0(f) + 1)","not idx < s0(f) + 1 or not f(s0(f)) or f(s0(f) + 1)","not idx < n or not f(n) or n.range.get_idx(idx) = Option.some(idx)","not f(s0(f).suc) or not f(0) or f(n)","not f(0) or f(s0(f)) or f(n)","s0(f) + 1 = s0(f).suc"]}
{"goal":"map_range","proof":["let s0: Nat satisfy { not idx < n.range.length or n.range.get_idx(idx) = Option.some(s0) and (not idx < n.range.length or map[Nat, T](n.range, f).get_idx(idx) = Option.some(f(s0))) }","not idx < n or n.range.get_idx(idx) = Option.some(idx)","Option.some(s0) != Option.some(idx) or s0 = idx","n.range.length = n"]}
{"goal":"f_out.length = n","proof":["map[Nat, T](n.range, f).length = n.range.length","n.range.length = n"]}
{"goal":"exists(k0: Nat, k1: Nat) { k0 < k1 and k1 < n and f_out.get_idx(k0) = f_out.get_idx(k1) }","proof":["let (s0: List[T] -> Nat, s1: List[T] -> Nat) satisfy { forall(x0: List[T]) { not x0.unique.length < x0.length or s0(x0) < s1(x0) } and forall(x1: List[T]) { not x1.unique.length < x1.length or s1(x1) < x1.length } and forall(x2: List[T]) { not x2.unique.length < x2.length or x2.get_idx(s1(x2)) = x2.get_idx(s0(x2)) } }","f_out.get_idx(s1(f_out)) != f_out.get_idx(s0(f_out)) or not s1(f_out) < n or not s0(f_out) < s1(f_out)","not f_out.unique.length < f_out.length or f_out.get_idx(s1(f_out)) = f_out.get_idx(s0(f_out))","not f_out.unique.length < f_out.length or s1(f_out) < f_out.length","not f_out.unique.length < f_out.length or s0(f_out) < s1(f_out)"]}
{"goal":"map[Nat, T](n.range, f).get_idx(i) = Option.some(f(i))","proof":["not i < n or map[Nat, T](n.range, f).get_idx(i) = Option.some(f(i))","not n <= i or not j < n or j < i","n <= i or i < n","not j < i or not i < j"]}
{"goal":"f(i) = f(j)","proof":["not j < n or map[Nat, T](n.range, f).get_idx(j) = Option.some(f(j))","Option.some(f(j)) != Option.some(f(i)) or f(j) = f(i)"]}
{"goal":"range_pigeonhole","proof":["not j < n or not i < j or f(j) != f(i)"]}
{"goal":"exists(k0: Nat) { k0.suc = i }","proof":["let s0: Nat -> Nat satisfy { forall(x0: Nat) { s0(x0).suc = x0 or 0 = x0 } }","s0(i).suc != i","s0(i).suc = i or i = 0"]}
{"goal":"List.cons(head, tail).get_idx(i) = tail.get_idx(i_pred)","proof":["i < 0 or 0 < i or i = 0","i > 0 = 0 < i","i_pred.suc - 1 = i_pred","not i < 0","not i > 0 or List.cons(head, tail).get_idx(i) = tail.get_idx(i - 1)"]}
{"goal":"List.cons(head, tail).get_idx(i) = Option.none[T]","proof":["not i_pred >= tail.length or not p(tail) or tail.get_idx(i_pred) = Option.none[T]","not tail.length.suc <= i_pred.suc or tail.length <= i_pred","List.cons(head, tail).length <= i = i >= List.cons(head, tail).length","tail.length <= i_pred = i_pred >= tail.length","List.cons(head, tail).length = tail.length.suc"]}
{"goal":"p(List.cons(head, tail))","proof":["let s0: List[T] -> Nat satisfy { forall(x0: Nat, x1: List[T]) { not x0 >= x1.length or not p(x1) or x1.get_idx(x0) = Option.none[T] } and forall(x2: List[T]) { s0(x2) >= x2.length or p(x2) } and forall(x3: List[T]) { x3.get_idx(s0(x3)) != Option.none[T] or p(x3) } }","List.cons(head, tail).get_idx(s0(List.cons(head, tail))) != Option.none[T] or p(List.cons(head, tail))","s0(List.cons(head, tail)) >= List.cons(head, tail).length or p(List.cons(head, tail))","not s0(List.cons(head, tail)) >= List.cons(head, tail).length or List.cons(head, tail).get_idx(s0(List.cons(head, tail))) = Option.none[T] or s0(List.cons(head, tail)) = 0","List.cons(head, tail).length <= s0(List.cons(head, tail)) = s0(List.cons(head, tail)) >= List.cons(head, tail).length","not tail.length.suc <= 0 or tail.length.suc = 0","tail.length.suc != 0","List.cons(head, tail).length = tail.length.suc"]}
{"goal":"get_idx_out_of_bounds","proof":["let (s0: (List[T] -> Bool) -> T, s1: (List[T] -> Bool) -> List[T]) satisfy { forall(x0: List[T] -> Bool, x1: List[T]) { not x0(List.nil[T]) or x0(s1(x0)) or x0(x1) } and forall(x2: List[T] -> Bool, x3: List[T]) { not x2(List.cons(s0(x2), s1(x2))) or not x2(List.nil[T]) or x2(x3) } }","not p(s1(p)) or p(List.cons(s0(p), s1(p)))","let s2: List[T] -> Nat satisfy { forall(x4: Nat, x5: List[T]) { not x4 >= x5.length or not p(x5) or x5.get_idx(x4) = Option.none[T] } and forall(x6: List[T]) { s2(x6) >= x6.length or p(x6) } and forall(x7: List[T]) { x7.get_idx(s2(x7)) != Option.none[T] or p(x7) } }","List.nil[T].get_idx(s2(List.nil[T])) != Option.none[T] or p(List.nil[T])","not idx >= list.length or not p(list) or list.get_idx(idx) = Option.none[T]","not p(List.cons(s0(p), s1(p))) or not p(List.nil[T]) or p(list)","not p(List.nil[T]) or p(s1(p)) or p(list)","List.nil[T].get_idx(s2(List.nil[T])) = Option.none[T]"]}
{"goal":"exists(k0: T, k1: List[T]) { lb = List.cons(k0, k1) }","proof":["let (s0: List[T] -> T, s1: List[T] -> List[T]) satisfy { forall(x0: List[T]) { List.cons(s0(x0), s1(x0)) = x0 or List.nil[T] = x0 } }","List.cons(s0(lb), s1(lb)) != lb","List.cons(s0(lb), s1(lb)) = lb or List.nil[T] = lb"]}
{"goal":"lb.get_idx(0) = Option.some(hb)","proof":["List.cons(hb, tb) != lb or 0 > 0 or lb.get_idx(0) = Option.some(hb)","0 > 0 = 0 < 0","not 0 < 0"]}
{"goal":"List.nil[T].get_idx(0) != lb.get_idx(0)","proof":["Option.some(hb) != Option.none[T]","List.nil[T].get_idx(0) = Option.none[T]"]}
{"goal":"differ[T](List.nil[T], lb, n)","proof":["not 0 < n or differ[T](List.nil[T], lb, n) or List.nil[T].get_idx(0) = lb.get_idx(0)","not 0 <= n or 0 < n or n = 0","not n >= lb.length or lb.get_idx(n) = Option.none[T]","lb.length <= n = n >= lb.length","List.nil[T].get_idx(0) = Option.none[T]"]}
{"goal":"p(List.nil[T])","proof":["let s0: List[T] -> List[T] satisfy { forall(x0: List[T], x1: List[T]) { not x0.length <= n or not x1.length <= n or not p(x0) or differ[T](x0, x1, n) or x0 = x1 } and forall(x2: List[T]) { s0(x2) != x2 or p(x2) } and forall(x3: List[T]) { x3.length <= n or p(x3) } and forall(x4: List[T]) { s0(x4).length <= n or p(x4) } and forall(x5: List[T]) { not differ[T](x5, s0(x5), n) or p(x5) } }","s0(List.nil[T]) != List.nil[T] or p(List.nil[T])","List.nil[T].length <= n or p(List.nil[T])","not differ[T](List.nil[T], s0(List.nil[T]), n) or p(List.nil[T])","s0(List.nil[T]).length <= n or p(List.nil[T])","not List.nil[T].length <= n or not s0(List.nil[T]).length <= n or differ[T](List.nil[T], s0(List.nil[T]), n) or s0(List.nil[T]) = List.nil[T]"]}
{"goal":"List.cons(ha, ta).get_idx(0) = Option.some(ha)","proof":["List.cons(ha, ta) != List.cons(ha, ta) or 0 > 0 or List.cons(ha, ta).get_idx(0) = Option.some(ha)","0 > 0 = 0 < 0","not 0 < 0"]}
{"goal":"List.cons(ha, ta).get_idx(0) != lb.get_idx(0)","proof":["Option.some(ha) != Option.none[T]","List.nil[T].get_idx(0) = Option.none[T]"]}
{"goal":"differ[T](List.cons(ha, ta), lb, n)","proof":["not 0 < n or differ[T](List.cons(ha, ta), lb, n) or List.cons(ha, ta).get_idx(0) = lb.get_idx(0)","not n >= List.cons(ha, ta).length or List.cons(ha, ta).get_idx(n) = Option.none[T]","n < 0 or 0 < n or n = 0","List.nil[T] != lb or lb.get_idx(0) = Option.none[T]","List.cons(ha, ta).length <= n = n >= List.cons(ha, ta).length","not n < 0"]}
{"goal":"exists(k0: T, k1: List[T]) { lb = List.cons(k0, k1) }","proof":["let (s0: List[T] -> T, s1: List[T] -> List[T]) satisfy { forall(x0: List[T]) { List.cons(s0(x0), s1(x0)) = x0 or List.nil[T] = x0 } }","List.cons(s0(lb), s1(lb)) != lb","List.cons(s0(lb), s1(lb)) = lb or List.nil[T] = lb"]}
{"goal":"List.cons(ha, ta).get_idx(0) = Option.some(ha)","proof":["List.cons(ha, ta) != List.cons(ha, ta) or 0 > 0 or List.cons(ha, ta).get_idx(0) = Option.some(ha)","0 > 0 = 0 < 0","not 0 < 0"]}
{"goal":"List.cons(hb, tb).get_idx(0) = Option.some(hb)","proof":["List.cons(hb, tb) != lb or 0 > 0 or lb.get_idx(0) = Option.some(hb)","0 > 0 = 0 < 0","not 0 < 0"]}
{"goal":"tb.length < n","proof":["let (s0: T, s1: List[T]) satisfy { List.cons(s0, s1) = lb }","List.cons(s0, s1) != lb or s1.length.suc = lb.length","not tb.length.suc <= n or not tb.length < tb.length.suc or tb.length < n","List.cons(hb, tb) != lb or lb.tail = tb","List.cons(s0, s1) != lb or lb.tail = s1","tb.length < tb.length.suc"]}
{"goal":"differ[T](ta, tb, n)","proof":["not ta.length <= n or not tb.length <= n or not p(ta) or differ[T](ta, tb, n) or tb = ta","not n < ta.length or n < ta.length.suc","not tb.length < n or tb.length <= n","not List.cons(ha, ta).length <= n or not n < List.cons(ha, ta).length","ta.length <= n or n < ta.length","List.cons(ha, ta).length = ta.length.suc"]}
{"goal":"exists(k0: Nat) { k0 < n and ta.get_idx(k0) != tb.get_idx(k0) }","proof":["let s0: (List[T], List[T], Nat) -> Nat satisfy { forall(x0: List[T], x1: List[T], x2: Nat) { not differ[T](x0, x1, x2) or s0(x0, x1, x2) < x2 } and forall(x3: List[T], x4: List[T], x5: Nat) { x3.get_idx(s0(x3, x4, x5)) != x4.get_idx(s0(x3, x4, x5)) or not differ[T](x3, x4, x5) } and forall(x6: Nat, x7: Nat, x8: List[T], x9: List[T]) { not x6 < x7 or differ[T](x8, x9, x7) or x8.get_idx(x6) = x9.get_idx(x6) } }","not s0(ta, tb, n) < n or tb.get_idx(s0(ta, tb, n)) = ta.get_idx(s0(ta, tb, n))","tb.get_idx(s0(ta, tb, n)) != ta.get_idx(s0(ta, tb, n)) or not differ[T](ta, tb, n)","not differ[T](ta, tb, n) or s0(ta, tb, n) < n"]}
{"goal":"exists(k0: Nat) { k0.suc = n }","proof":["i.suc != n","not i < n or i.suc < n or i.suc = n","not i.suc ∈ n.range or not i.suc >= n","not i.suc < n or i.suc ∈ n.range"]}
{"goal":"i = ip","proof":["not i < n or i.suc < n or i.suc = n","n <= i.suc = i.suc >= n","not n <= i.suc or not i.suc < n","ip.suc != i.suc or ip = i"]}
{"goal":"ta.length <= ip","proof":["not ta.length.suc <= ip.suc or ta.length <= ip","List.cons(ha, ta).length = ta.length.suc"]}
{"goal":"tb.length <= ip","proof":["let (s0: T, s1: List[T]) satisfy { List.cons(s0, s1) = lb }","List.cons(s0, s1) != lb or s1.length.suc = lb.length","not tb.length.suc <= ip.suc or tb.length <= ip","List.cons(hb, tb) != lb or lb.tail = tb","List.cons(s0, s1) != lb or lb.tail = s1"]}
{"goal":"false","proof":["not ip >= ta.length or ta.get_idx(ip) = Option.none[T]","not ip >= tb.length or tb.get_idx(ip) = Option.none[T]","ta.length <= ip = ip >= ta.length","tb.length <= ip = ip >= tb.length"]}
{"goal":"i.suc > 0","proof":["i.suc > 0 = 0 < i.suc","0 < 0 + i.suc","0 + i.suc = i.suc"]}
{"goal":"List.cons(ha, ta).get_idx(i.suc) = ta.get_idx(i)","proof":["i.suc - 1 = i","not i.suc > 0 or List.cons(ha, ta).get_idx(i.suc) = ta.get_idx(i.suc - 1)"]}
{"goal":"List.cons(hb, tb).get_idx(i.suc) = tb.get_idx(i)","proof":["i.suc - 1 = i","not i.suc > 0 or List.cons(hb, tb).get_idx(i.suc) = tb.get_idx(i.suc - 1)"]}
{"goal":"differ[T](List.cons(ha, ta), lb, n)","proof":["not i.suc < n or differ[T](List.cons(ha, ta), lb, n) or List.cons(ha, ta).get_idx(i.suc) = lb.get_idx(i.suc)","n <= i.suc = i.suc >= n","n <= i.suc or i.suc < n"]}
{"goal":"0 < n","proof":["not lb.length <= n or not 0 < lb.length or 0 < n","lb.length < 0 or 0 < lb.length or lb.length = 0","lb.length != 0 or List.nil[T] = lb","not lb.length < 0"]}
{"goal":"differ[T](List.cons(ha, ta), lb, n)","proof":["not 0 < n or differ[T](List.cons(ha, ta), lb, n) or List.cons(ha, ta).get_idx(0) = lb.get_idx(0)","Option.some(hb) != Option.some(ha) or hb = ha"]}
{"goal":"p(a)","proof":["let (s0: T, s1: List[T]) satisfy { forall(x0: List[T]) { not p(List.nil[T]) or p(s1) or p(x0) } and forall(x1: List[T]) { not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(x1) } }","not p(List.nil[T]) or p(s1) or p(a)","let s2: List[T] -> List[T] satisfy { forall(x2: List[T], x3: List[T]) { not x2.length <= n or not x3.length <= n or not p(x2) or differ[T](x2, x3, n) or x2 = x3 } and forall(x4: List[T]) { s2(x4) != x4 or p(x4) } and forall(x5: List[T]) { x5.length <= n or p(x5) } and forall(x6: List[T]) { s2(x6).length <= n or p(x6) } and forall(x7: List[T]) { not differ[T](x7, s2(x7), n) or p(x7) } }","s2(List.cons(s0, s1)) != List.cons(s0, s1) or p(List.cons(s0, s1))","not p(List.cons(s0, s1)) or not p(List.nil[T]) or p(a)","List.cons(s0, s1).length <= n or p(List.cons(s0, s1))","not differ[T](List.cons(s0, s1), s2(List.cons(s0, s1)), n) or p(List.cons(s0, s1))","s2(List.cons(s0, s1)).length <= n or p(List.cons(s0, s1))","not List.cons(s0, s1).length <= n or not s2(List.cons(s0, s1)).length <= n or not p(s1) or differ[T](List.cons(s0, s1), s2(List.cons(s0, s1)), n) or s2(List.cons(s0, s1)) = List.cons(s0, s1)"]}
{"goal":"differ[T](a, b, n)","proof":["not a.length <= n or not b.length <= n or not p(a) or differ[T](a, b, n) or b = a"]}
{"goal":"lists_differ_at_index","proof":[]}
{"goal":"partial_zero","proof":["sum[A](map[Nat, A](0.range, f)) = partial[A](f, 0)","List.nil[Nat] != List.nil[Nat] or map[Nat, A](List.nil[Nat], f) = List.nil[A]","sum[A](map[Nat, A](0.range, f)) != A.0","List.nil[A] != List.nil[A] or sum[A](List.nil[A]) = A.0","0 != 0 or 0.range = List.nil[Nat]","0.range = List.nil[Nat]","sum[A](List.nil[A]) = A.0","sum[A](map[Nat, A](List.nil[Nat], f)) != A.0","map[Nat, A](List.nil[Nat], f) = List.nil[A]"]}
{"goal":"differ[T](a, b, a.length)","proof":["a.length <= a.length"]}
{"goal":"a = b","proof":["let s0: (List[T], List[T], Nat) -> Nat satisfy { forall(x0: List[T], x1: List[T], x2: Nat) { not differ[T](x0, x1, x2) or s0(x0, x1, x2) < x2 } and forall(x3: List[T], x4: List[T], x5: Nat) { x3.get_idx(s0(x3, x4, x5)) != x4.get_idx(s0(x3, x4, x5)) or not differ[T](x3, x4, x5) } and forall(x6: Nat, x7: Nat, x8: List[T], x9: List[T]) { not x6 < x7 or differ[T](x8, x9, x7) or x8.get_idx(x6) = x9.get_idx(x6) } }","not s0(a, b, a.length) < a.length or b.get_idx(s0(a, b, a.length)) = a.get_idx(s0(a, b, a.length))","b.get_idx(s0(a, b, a.length)) != a.get_idx(s0(a, b, a.length)) or not differ[T](a, b, a.length)","not differ[T](a, b, a.length) or s0(a, b, a.length) < a.length"]}
{"goal":"list_extensionality","proof":["let s0: Nat satisfy { b.length != a.length or s0 < a.length or b = a and (b.get_idx(s0) != a.get_idx(s0) or b.length != a.length or b = a) }","not s0 < a.length or b.get_idx(s0) = a.get_idx(s0)"]}
