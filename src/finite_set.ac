from nat import Nat
from set import Set

numerals Nat

/// A finite set is a `Set` bundled with a finiteness proof.
structure FiniteSet[T] {
    /// The underlying set.
    underlying_set: Set[T]
} constraint {
    underlying_set.is_finite
}

attributes FiniteSet[T] {
    /// Access the underlying set.
    define as_set(self) -> Set[T] {
        self.underlying_set
    }

    /// Membership predicate.
    define contains(self, x: T) -> Bool {
        self.underlying_set.contains(x)
    }

    /// The empty finite set.
    let empty: FiniteSet[T] = FiniteSet.new(Set[T].empty_set)

    let singleton: T -> FiniteSet[T] = function (a: T) {
        FiniteSet.new(Set.singleton(a))
    }

    /// Insert preserves finiteness.
    define insert(self, item: T) -> FiniteSet[T] {
        FiniteSet.new(self.underlying_set.insert(item))
    }

    /// Remove preserves finiteness.
    define remove(self, item: T) -> FiniteSet[T] {
        FiniteSet.new(self.underlying_set.remove(item))
    }

    /// Subset relation lifted from sets.
    define subset_eq(self, other: FiniteSet[T]) -> Bool {
        self.underlying_set.subset(other.underlying_set)
    }

    /// Superset relation lifted from sets.
    define superset_eq(self, other: FiniteSet[T]) -> Bool {
        self.underlying_set.superset(other.underlying_set)
    }

    /// Union of finite sets.
    define union(self, other: FiniteSet[T]) -> FiniteSet[T] {
        FiniteSet.new(self.underlying_set.union(other.underlying_set))
    }

    /// Intersection of finite sets.
    define intersection(self, other: FiniteSet[T]) -> FiniteSet[T] {
        FiniteSet.new(self.underlying_set.intersection(other.underlying_set))
    }

    /// Difference of finite sets.
    define difference(self, other: FiniteSet[T]) -> FiniteSet[T] {
        FiniteSet.new(self.underlying_set.difference(other.underlying_set))
    }

    /// Disjointness predicate.
    define is_disjoint(self, other: FiniteSet[T]) -> Bool {
        self.underlying_set.is_disjoint(other.underlying_set)
    }

    /// Empty predicate.
    define is_empty(self) -> Bool {
        self.underlying_set.is_empty
    }

    /// Cardinality helper lifted from sets.
    define cardinality_at_most(self, n: Nat) -> Bool {
        self.underlying_set.cardinality_at_most(n)
    }

    /// True if the cardinality equals n.
    define cardinality_is(self, n: Nat) -> Bool {
        self.underlying_set.cardinality_is(n)
    }

    define map[U](self, f: T -> U) -> FiniteSet[U] {
        FiniteSet.new(self.underlying_set.map(f))
    }
}

from add_comm_monoid import AddCommMonoid
from list import List, sum

attributes FiniteSet[A: AddCommMonoid] {
    define sum_is(self, n: A) -> Bool {
        exists(l: List[A]) {
            l.contains = self.contains and l.is_unique and sum(l) = n
        }
    }
}

// Why does the AI not one-shot these theorems?
theorem map_contains_image[T, S](s: FiniteSet[T], f: T -> S, x: T) {
    s.contains(x) implies s.map(f).contains(f(x))
} by {
    s.underlying_set.contains(x) implies s.underlying_set.map(f).contains(f(x))
    s.contains(x) = s.underlying_set.contains(x)
    s.underlying_set.map(f).contains(f(x)) = s.map(f).contains(f(x))
}

theorem underlying_set_is_set[T](s: Set[T]) {
    s.is_finite implies FiniteSet.new(s).underlying_set = s
}

theorem singleton_is_same_as_set[T](x: T, y: T) {
    FiniteSet.singleton(x).contains(y) = Set.singleton(x).contains(y)
} by {
    let fin_s = FiniteSet.singleton(x)
    let s = Set.singleton(x)
    s.is_finite

    fin_s = FiniteSet.new(s)
    FiniteSet.new(s).underlying_set = s
    fin_s.underlying_set = s

    fin_s.contains(y) = s.contains(y)
}

// I have no idea but this seems to also be needed
theorem singleton_contains_item[T](x: T, y: T) {
    FiniteSet.singleton(x).contains(x)
}

theorem finite_map_preserves_singleton[T, U](x: T, f: T -> U) {
    FiniteSet.singleton(x).map(f) = FiniteSet.singleton(f(x))
} by {
    let fin_s = FiniteSet.singleton(x)
    let s = Set.singleton(x)
    s.is_finite

    fin_s = FiniteSet.new(s)
    FiniteSet.new(s).underlying_set = s
    fin_s.underlying_set = s

    fin_s.map(f).underlying_set = s.map(f)
    s.map(f) = Set.singleton(f(x))
    FiniteSet.new(Set.singleton(f(x))).underlying_set = Set.singleton(f(x))

    fin_s.map(f).underlying_set = FiniteSet.new(Set.singleton(f(x))).underlying_set

    fin_s.map(f) = FiniteSet.new(Set.singleton(f(x)))
    fin_s.map(f) = FiniteSet.singleton(f(x))
}

theorem sum_of_singleton_is_element[T: AddCommMonoid](x: T) {
    FiniteSet.singleton(x).sum_is(x)
} by {
    let fin_s = FiniteSet.singleton(x)
    let list_s = List.singleton(x)
    list_s.contains = fin_s.contains
}